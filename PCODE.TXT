.context AddL
.context AddT
.context AddW
.context @L8000
:z3
                                              \aUp\vadvisor.hlp!h.contents\v \aContents\vadvisor.hlp!h.contents\v \aIndex\vadvisor.hlp!h.index\v \aBack\v!B\v
컴P-Code Instructions컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 
:nAdd<t>
  Syntax
 
  Add<t>
 
  /* Add top two items on stack */
 
  Possible Instructions
 
  AddW, AddL, AddT
 
  See: \aP-Code Data Types\v@L8070\v
 
  Description
 
  Adds the top two elements from the stack and pushes the result onto the
  stack. The length of the elements is determined by the <t> portion of
  the instruction.
 
  Pseudocode equivalent:
 
  <t>2 = Pop<t>();
  <t>1 = Pop<t>();
  Push<t>(<t>1 + <t>2);
 
 
                                     --
 
.context AddWP
.context @L8001
:z3
                                              \aUp\vadvisor.hlp!h.contents\v \aContents\vadvisor.hlp!h.contents\v \aIndex\vadvisor.hlp!h.index\v \aBack\v!B\v
컴P-Code Instructions컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 
:nAddWP
  Syntax
 
  AddWP
 
  /* Add scaled integer word to pointer */
 
  Description
 
  Performs the addition of a scaled integer to a pointer. This requires
  the multiplication of the integer by the number of bytes per word before
  the addition takes place.
 
  Pseudocode equivalent:
 
  w2 = PopW();
  w1 = PopW();
  PushW(w1 + w2 * 2);
 
  This can be generated by assigning an integer value to an element of an
  array of integers, as follows:
 
  for( iw = 0; iw < 6; iw++ )
  rgw[iw] = iw                /* generates AddWP */
 
 
                                     --
 
.context AndL
.context AndW
.context @L8002
:z3
                                              \aUp\vadvisor.hlp!h.contents\v \aContents\vadvisor.hlp!h.contents\v \aIndex\vadvisor.hlp!h.index\v \aBack\v!B\v
컴P-Code Instructions컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 
:nAnd<t>
  Syntax
 
  And<t>
 
  /* Bitwise logical 'and' top two items on stack */
 
  Possible Instructions
 
  AndW, AndL
 
  See: \aP-Code Data Types\v@L8070\v
 
  Description
 
  Pops two elements from the stack, performs a logical and on them, and
  pushes the result back onto the stack.
 
  Pseudocode equivalent:
 
  <t>2 = Pop<t>();
  <t>1 = Pop<t>();
  Push<t>(<t>1 & <t>2);
 
  This is generated by
 
  wTest1 = 23;
  wTest2 = 14;
  if ((wTest1 & wTest2) != 6) /* generate AndW */
 
 
                                     --
 
.context BltFFB
.context @L8003
:z3
                                              \aUp\vadvisor.hlp!h.contents\v \aContents\vadvisor.hlp!h.contents\v \aIndex\vadvisor.hlp!h.index\v \aBack\v!B\v
컴P-Code Instructions컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 
:nBltFFB
  Syntax
 
  BltFFB
 
  /* Block copy using far pointers. */
 
  Description
 
  Performs a byte block copy using far pointers and a count found on the
  top of the evaluation stack.
 
  Pseudocode equivalent:
 
  cb = PopW();
  lpbDest = PopL();
  lpbSrc = PopL();
  copy cb bytes from lpbSrc to lpbDest
 
 
                                     --
 
.context BltFFBF
.context @L8004
:z3
                                              \aUp\vadvisor.hlp!h.contents\v \aContents\vadvisor.hlp!h.contents\v \aIndex\vadvisor.hlp!h.index\v \aBack\v!B\v
컴P-Code Instructions컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 
:nBltFFBF
  Syntax
 
  BltFFBF
 
  /* Block copy using far pointers and returning a far pointer. */
 
  Description
 
  Performs a byte block copy using far pointers. A pointer to the byte
  following the block copied is pushed onto the stack as a result of the
  operation.
 
  Pseudocode equivalent:
 
  cb = PopW();
  lpbDest = PopL();
  lpbSrc = PopL();
  copy cb bytes from lpbSrc to lpbDest
  PushL(lpbDest+cb);
 
 
                                     --
 
.context CallD#
.context @L8005
:z3
                                              \aUp\vadvisor.hlp!h.contents\v \aContents\vadvisor.hlp!h.contents\v \aIndex\vadvisor.hlp!h.index\v \aBack\v!B\v
컴P-Code Instructions컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 
:nCallD#
  Syntax
 
  CallD#
 
  /* Direct p-code call; pop parameters and push return values */
 
  Description
 
  Calls a procedure in a p-code segment different from the currently
  executing procedure's segment. The implicit operand is an index into the
  current procedure's call table. This index is used to fetch a 1-byte
  index into the current segment's call table, which in turn is used to
  fetch a 2-byte PD (Procedure Descriptor).
 
  The PD identifies the entry point for the called procedure. It consists
  of an SN (Segment Number) and an EN (Entry Number).
 
 
                                     --
 
.context CallDb
.context @L8006
:z3
                                              \aUp\vadvisor.hlp!h.contents\v \aContents\vadvisor.hlp!h.contents\v \aIndex\vadvisor.hlp!h.index\v \aBack\v!B\v
컴P-Code Instructions컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 
:nCallDb
  Syntax
 
  CallDb
 
  /* Direct p-code call; pop parameters and push return values */
 
  Description
 
  Like CallD#, this instruction calls a procedure in a p-code segment
  different from the currently executing procedure's segment. However, an
  immediate operand specifies the 1-byte index into the current segment's
  call table. In other words, the first fetch performed by "CallD#" is
  replaced by a fetch from the instruction stream.
 
  See: \aCallD#\v@L8005\v
 
 
                                     --
 
.context CallDbb
.context @L8007
:z3
                                              \aUp\vadvisor.hlp!h.contents\v \aContents\vadvisor.hlp!h.contents\v \aIndex\vadvisor.hlp!h.index\v \aBack\v!B\v
컴P-Code Instructions컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 
:nCallDbb
  Syntax
 
  CallDbb
 
  /* Direct p-code call; pop parameters and push return values */
 
  Description
 
  Like CallDb, this instruction calls a procedure in a p-code segment
  different from the currently executing procedure's segment.
 
  However, it has a second 1-byte immediate operand that specifies the
  number of bytes of parameters that are being passed to the called
  procedure. This parameter count overrides the default for the procedure
  specified in its entry point.
 
  See: \aCallDb\v@L8006\v
 
 
                                     --
 
.context CallDbw
.context @L8008
:z3
                                              \aUp\vadvisor.hlp!h.contents\v \aContents\vadvisor.hlp!h.contents\v \aIndex\vadvisor.hlp!h.index\v \aBack\v!B\v
컴P-Code Instructions컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 
:nCallDbw
  Syntax
 
  CallDbw
 
  /* Direct p-code call; pop parameters and push return values */
 
  Description
 
  Like CallDb, this instruction calls a procedure in a p-code segment
  different from the currently executing procedure's segment, specifying a
  parameter byte count.
 
  However, the parameter byte count is two bytes long instead of one. This
  instruction is used when 256 or more bytes of parameters are being
  passed.
 
  See: \aCallDb\v@L8006\v
 
 
                                     --
 
.context CallS#
.context @L8009
:z3
                                              \aUp\vadvisor.hlp!h.contents\v \aContents\vadvisor.hlp!h.contents\v \aIndex\vadvisor.hlp!h.index\v \aBack\v!B\v
컴P-Code Instructions컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 
:nCallS#
  Syntax
 
  CallS#
 
  /* Direct p-code call; pop parameters and push return values */
 
  Description
 
  Calls a procedure in the same p-code segment as the currently executing
  procedure.
 
  The implicit operand is an index into the current procedure's call
  table. This index is used to fetch the one-byte EN (Entry Number), an
  index into the current p-code segment's table of entry points.
 
 
                                     --
 
.context CallSb
.context @L800a
:z3
                                              \aUp\vadvisor.hlp!h.contents\v \aContents\vadvisor.hlp!h.contents\v \aIndex\vadvisor.hlp!h.index\v \aBack\v!B\v
컴P-Code Instructions컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 
:nCallSb
  Syntax
 
  CallSb
 
  /* Direct p-code call; pop parameters and push return values */
 
  Description
 
  Like CallS#, this instruction calls a procedure in the same p-code
  segment as the currently executing procedure.
 
  However, an immediate operand specifies the one-byte EN (Entry Number).
  In other words, the first fetch performed by "CallS#" is replaced by a
  fetch from the instruction stream.
 
  See: \aCallS#\v@L8009\v
 
 
                                     --
 
.context CallSbb
.context @L800b
:z3
                                              \aUp\vadvisor.hlp!h.contents\v \aContents\vadvisor.hlp!h.contents\v \aIndex\vadvisor.hlp!h.index\v \aBack\v!B\v
컴P-Code Instructions컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 
:nCallSbb
  Syntax
 
  CallSbb
 
  /* Direct p-code call; pop parameters and push return values */
 
  Description
 
  Like CallSb, this instruction calls a procedure in the same p-code
  segment as the currently executing procedure.
 
  However, a second one-byte immediate operand specifies the number of
  bytes of parameters that are being passed to the called procedure. This
  parameter count overrides the default for that procedure specified in
  its entry point.
 
  See: \aCallSb\v@L800a\v
 
 
                                     --
 
.context CallSbw
.context @L800c
:z3
                                              \aUp\vadvisor.hlp!h.contents\v \aContents\vadvisor.hlp!h.contents\v \aIndex\vadvisor.hlp!h.index\v \aBack\v!B\v
컴P-Code Instructions컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 
:nCallSbw
  Syntax
 
  CallSbw
 
  /* Direct p-code call; pop parameters and push return values */
 
  Description
 
  Like CallSbb, this instruction calls a procedure in the same p-code
  segment as the currently executing procedure, specifying a parmeter byte
  count.
 
  However, the parameter byte count is two bytes long instead of one. This
  instruction is used when 256 or more bytes of parameters are being
  passed.
 
  See: \aCallSb\v@L800a\v
 
 
                                     --
 
.context CallifcW
.context CallifcL
.context CallifcV
.context @L800d
:z3
                                              \aUp\vadvisor.hlp!h.contents\v \aContents\vadvisor.hlp!h.contents\v \aIndex\vadvisor.hlp!h.index\v \aBack\v!B\v
컴P-Code Instructions컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 
:nCallifc<t>
  Syntax
 
  Callifc<t>
 
  /* Indirect call to __far __cdecl function with return type <t> */
 
  Possible Instructions
 
  CallifcV, CallifcW, CallifcL
 
  See: \aP-Code Data Types\v@L8070\v
 
  Description
 
  Perform indirect calls to __far __cdecl functions. The address of the
  function is the long value on the top of the stack. The address must
  refer to either a native function or a p-code function with a native
  entry code sequence.
 
  The function is assumed to return an item of length <t>. The end
  processing of the call instruction will push the return value onto the
  stack.
 
  The instruction must be followed by an additional byte containing the
  number of words of parameters that were pushed onto the stack for this
  call. They will be popped off by the interpreter when it processes the
  end of the call instruction.
 
  Pseudocode equivalent:
 
  lpfn = PopL(); (V|L|W) = (*lpfn)();  // V=void, W=word, L=long
  push(V|L|W);
 
  The instruction is generated by a code sequence like the following:
 
  <t> = (*foo)(10);   /* generates a Callifc<t> */
 
 
                                     --
 
.context CallifpW
.context CallifpL
.context CallifpV
.context @L800e
:z3
                                              \aUp\vadvisor.hlp!h.contents\v \aContents\vadvisor.hlp!h.contents\v \aIndex\vadvisor.hlp!h.index\v \aBack\v!B\v
컴P-Code Instructions컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 
:nCallifp<t>
  Syntax
 
  Callifp<t>
 
  /* Indirect call to __far __pascal function returning type <t> */
 
  Possible Instructions
 
  CallifpV, CallifpW, CallifpL
 
  See: \aP-Code Data Types\v@L8070\v
 
  Description
 
  Perform indirect calls to __far __pascal functions. The address of the
  function is the long value on the top of the stack. The address must
  refer to either a native function or a p-code function with a native
  entry code sequence.
 
  The function is assumed to return an item of length <t>. The end
  processing of the call instruction will push the return value onto the
  stack.
 
  The instruction is generated by a code sequence like the following:
 
  <t> = (*foo)(10);        /* generates Callifp<t> */
 
 
                                     --
 
.context CallincW
.context CallincL
.context CallincV
.context @L800f
:z3
                                              \aUp\vadvisor.hlp!h.contents\v \aContents\vadvisor.hlp!h.contents\v \aIndex\vadvisor.hlp!h.index\v \aBack\v!B\v
컴P-Code Instructions컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 
:nCallinc<t>
  Syntax
 
  Callinc<t>
 
  /* Indirect call to __near __cdecl function returning type <t> */
 
  Possible Instructions
 
  CallincV, CallincW, CallincL
 
  See: \aP-Code Data Types\v@L8070\v
 
  Description
 
  Perform indirect calls to __near __cdecl functions that return an item
  of length <t>. The address of the function is the word value on the top
  of the stack. The address must refer to either a native function or a
  p-code function with a native entry code sequence.
 
  The instruction must be followed by an additional byte containing the
  number of words of parameters that were pushed onto the stack for this
  call. They will be popped off by the interpreter as part of processing
  the end of the call instruction.
 
  The instruction is generated by a code sequence like the following:
 
  <t> = (*foo)(10);   /* generates a Callinc<t> */
 
 
                                     --
 
.context CallinpW
.context CallinpL
.context CallinpV
.context @L8010
:z3
                                              \aUp\vadvisor.hlp!h.contents\v \aContents\vadvisor.hlp!h.contents\v \aIndex\vadvisor.hlp!h.index\v \aBack\v!B\v
컴P-Code Instructions컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 
:nCallinp<t>
  Syntax
 
  Callinp<t>
 
  /* Indirect call to __near __pascal function returning type <t> */
 
  Possible Instructions
 
  CallinpV, CallinpW, CallinpL
 
  See: \aP-Code Data Types\v@L8070\v
 
  Description
 
  Perform indirect calls to __near __pascal functions. The address of the
  function is the word value on the top of the stack. The address must
  refer to either a native function or a p-code function with a native
  entry code sequence.
 
  The function is assumed to return an item of length <t>. The end
  processing of the call instruction will push the return value onto the
  stack.
 
  The instruction is generated by a code sequence like the following:
 
  <t> = (*foo)(10);   /* generates a Callinp<t> */
 
 
                                     --
 
.context Callxbb
.context @L8011
:z3
                                              \aUp\vadvisor.hlp!h.contents\v \aContents\vadvisor.hlp!h.contents\v \aIndex\vadvisor.hlp!h.index\v \aBack\v!B\v
컴P-Code Instructions컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 
:nCallxbb
  Syntax
 
  Callxbb
 
  /* Call a virtual function */
 
  Calls a virtual function. A pointer to the instance is expected to be on
  the stack. (The size of the pointer is near or far according to the
  class def.) The 2 or 3 bytes following the opcode contain the following
  values:
 
       * bit 7: 0 = near class, 1 = far class
         bits 4-6: unused (!)
         bits 0-3: "call mode" specifying the
               calling convention and return
               value size. The encoding of a
               "call mode" is the same as the
               existing encoding defined by the
               interpreter (and designed for
               fast execution).
       * A signed offset within the vtable, used
         to locate the function pointer.
       * [if cdecl] Parameter size to be popped on
         return.
 
 
                                     --
 
.context Callybb
.context @L8012
:z3
                                              \aUp\vadvisor.hlp!h.contents\v \aContents\vadvisor.hlp!h.contents\v \aIndex\vadvisor.hlp!h.index\v \aBack\v!B\v
컴P-Code Instructions컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 
:nCallybb
  Syntax
 
  /* Multiple-inheritance virtual function call */
 
  Multiple-inheritance call to a virtual function. Like Callxbb, but an
  extra byte (immediately following the opcode) specifies a signed value
  to be added to the "this" pointer which is passed to the called
  procedure.
 
  See: \aCallxbb\v@L8011\v
 
 
                                     --
 
.context Case<t>
.context @L8013
:z3
                                              \aUp\vadvisor.hlp!h.contents\v \aContents\vadvisor.hlp!h.contents\v \aIndex\vadvisor.hlp!h.index\v \aBack\v!B\v
컴P-Code Instructions컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 
  Syntax
 
  Case<t>
 
  /* Perform Switch/Case operation using top word/long of stack */
 
  Description
 
  Implement case statements. Each case instruction is followed by one or
  more case entries. Each entry starts with a one- or two-byte control
  header. The remaining bytes in a case entry describe a case value or
  range of case values and list target addresses for each case value. The
  target addresses are pc-relative to the first byte following the Case<t>
  instruction ("pc" refers to the p-code instruction pointer).
 
  Each case value can be either a byte or a word. For the CaseL
  instruction, the value can be a long. Each pc-relative address can be
  either a byte or word.
 
  The control header record determines how and entry is decoded. The
  structure below describes the control header format, assuming an 80x86
  memory layout:
 
  struct caseEntry
           {
           word cShortRange    : 5;
           word fNear          : 1;
           word fWord          : 1;
           word fEnd           : 1;
           word cExtendedRange : 7;
           word fLong          : 1;
           } caseEntry;
 
      caseIP = IP;        // Get current IP
      nextIP = PopW();    // Get break address
      swexp<t> = Pop<t>();     // Get switch expression
      PushW(nextIP);      // Push break address
 
      for(;;)
           {
 
           // Get first byte of case entry and determine
           // if it is a short or long entry.
 
           *((byte *) caseEntry) = *IP++;
           if (caseEntry.cShortRange == 0x1f)
                {
 
                // Get value and range of long case
                // entry.
 
                *(((byte *) caseEntry)+1)  = *IP++;
                if (caseEntry.fLong)
                     {
                     val<t> = (<t>) *((long *) IP);
                     IP += sizeof(long);
                     }
                else if (caseEntry.fWord)
                     {
                     val<t> = (<t>) *((word *) IP);
                     IP += sizeof(word);
                     }
                else
                     {
                     val<t> = (<t>) *((byte *) IP);
                     IP += sizeof(byte);
                     }
 
                range = caseEntry.cExtendedRange;
 
                }
           else
                {
 
                // Get value and range of short case
                // entry.
 
                if (caseEntry.fWord)
                     {
                     val<t> = (<t>) *((word *) IP);
                     IP += sizeof(word);
                     }
                else
                     {
                     val<t> = (<t>) *((byte *) IP);
                     IP += sizeof(byte);
                     }
 
                range = caseEntry.cShortRange;
 
                }
 
           // Determine if the switch value falls
           // within this case range.
 
           if ((val<t> <= swval<t>)
           && (swval<t> <= (val<t> + range))
                {
 
                // Get word or byte target address
 
                i = swval<t> - val<t>;
                if (caseEntry.fNear)
                     IP = ((word *)IP)[i];
                else
                     IP = ((byte *)IP)[i]
 
                // Make address relative to Case
                // instruction.
 
                IP += caseIP;
 
                // Entry found, IP updated so stop.
 
                break;
 
                }
 
           // Case entry does not match, advance IP.
 
           if (caseEntry.fNear)
                IP += (range+1) * sizeof(word);
           else
                IP += (range+1) * sizeof(byte);
 
           // Test for last entry.
 
           if (caseEntry.fEnd)
                    break;
           }
 
  NOTE: It is assumed that a PushIP instruction is placed immediately
        before the Case<t> instruction, and that a PopIP instruction is
        placed immediately after the case entry table if no default has
        been specified.
 
        Each case sequence that ends in a break statment is terminated by
        PopIP. The target of the PushIP instruction must be the first
        instruction following the Case entry table.
 
 
                                     --
 
.context Chkstk
.context @L8014
:z3
                                              \aUp\vadvisor.hlp!h.contents\v \aContents\vadvisor.hlp!h.contents\v \aIndex\vadvisor.hlp!h.index\v \aBack\v!B\v
컴P-Code Instructions컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 
:nChkstk
  Syntax
 
  Chkstk
 
  /* Check for Stack Overflow */
 
  Description
 
  Generated by the compiler at the beginning of each p-code procedure for
  which stack checking (/Ge, the default) is enabled. It calls the native
  __chkstk routine, specifying a frame size of 0. If the stack has
  overflowed, an error message is generated.
 
 
                                     --
 
.context ClrfBb
.context @L8015
:z3
                                              \aUp\vadvisor.hlp!h.contents\v \aContents\vadvisor.hlp!h.contents\v \aIndex\vadvisor.hlp!h.index\v \aBack\v!B\v
컴P-Code Instructions컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 
:nClrfB<n>
  Syntax
 
  ClrfB<n>
 
  /* Clear Frame Byte */
 
  Possible Instructions
 
  ClrfBb
 
  Description
 
  Clears (sets to zero) a byte location on the frame.
 
  Pseudocode equivalent:
 
  [BP+(0xff00 & <n>)] = 0;
 
  The following statement generates this instruction:
 
  bFlag = 0;  /* generates ClrfB<n> */
 
 
                                     --
 
.context CmpsL
.context @L8016
:z3
                                              \aUp\vadvisor.hlp!h.contents\v \aContents\vadvisor.hlp!h.contents\v \aIndex\vadvisor.hlp!h.index\v \aBack\v!B\v
컴P-Code Instructions컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 
:nCmpsL
  Syntax
 
  CmpsL
 
  /* Compare top two signed longs on stack */
 
  Description
 
  Compares two signed longs on the stack.
 
  Pseudocode equivalent:
 
  l2 = (long *)Pop();
  l1 = (long *)Pop();
  Push(l1 == l2 ? 0 : (l1 > l2) ? 1 : -1);
  Push(0);
 
  The following code fragment shows how this instruction is generated:
 
  lTest1 = 99;
  lTest2 = lTest1 + 10000l;
  if (lTest2 != 10099l)    /* generates CmpsL */
 
 
                                     --
 
.context CmpT
.context @L8017
:z3
                                              \aUp\vadvisor.hlp!h.contents\v \aContents\vadvisor.hlp!h.contents\v \aIndex\vadvisor.hlp!h.index\v \aBack\v!B\v
컴P-Code Instructions컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 
:nCmpT
  Syntax
 
  CmpT
 
  /* Compare top two floating point values on floating point stack. */
 
  Description
 
  Compares two floating point values on the floating point stack in
  ten-byte real format.
 
  The evaluation stack is updated with a -1, 0, or 1, followed by a 0,
  depending on the results of the unsigned compare.
 
  Pseudocode equivalent:
 
  t2 = PopT();
  t1 = PopT();
  Push(t1 == t2 ? 0 : (t1 > t2) ? 1 : -1);
  Push(0);
 
  The following code fragment shows how this instruction is generated:
 
  Test1 = 99.00;
  Test2 = Test1 + 10000.00;
  if (Test2 > 10098.00)    /* generates CmpT */
 
 
                                     --
 
.context CmpuW
.context CmpuL
.context @L8018
:z3
                                              \aUp\vadvisor.hlp!h.contents\v \aContents\vadvisor.hlp!h.contents\v \aIndex\vadvisor.hlp!h.index\v \aBack\v!B\v
컴P-Code Instructions컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 
:nCmpu<t>
  Syntax
 
  Cmpu<t>
 
  /* Compare top two items on stack as unsigned values */
 
  Possible Instructions
 
  CmpuL, CmpuW
 
  See: \aP-Code Data Types\v@L8070\v
 
  Description
 
  Pops two elements from the stack and performs an unsigned compare on
  them. Depending on the results of the compare, a -1, 0, or 1 is pushed
  onto the stack, followed by a 0.
 
  These results can be then compared by the normal (signed) compares.
  Cmpu<t>, JgtW<n> is thus equivalent to an unsigned JgtW<n>.
 
  Pseudocode equivalent:
 
  unsigned u<t>1, u<t>2;
  u<t>2 = Pop<t>();
  u<t>1 = Pop<t>();
  Push(u<t>1 == u<t>2 ? 0 : (u<t>1 > u<t>2) ? 1 : -1);
  Push(0);
 
  The following example is one that generates this instruction:
 
  uTest1 = 99;
  uTest2 = 100;
  uTest1 = (uTest1 * uTest2 <10000 ? 0 : 1);
  /* generates CmpuW */
 
 
                                     --
 
.context CvtBW
.context @L8019
:z3
                                              \aUp\vadvisor.hlp!h.contents\v \aContents\vadvisor.hlp!h.contents\v \aIndex\vadvisor.hlp!h.index\v \aBack\v!B\v
컴P-Code Instructions컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 
:nCvtBW
  Syntax
 
  CvtBW
 
  /* Convert byte to word (sign extended) on top of stack. */
 
  Description
 
  Pops the word on top of the stack, sign extends the least significant
  byte, and pushes the resulting word back onto the stack.
 
  Pseudocode equivalent:
 
  b = (char) popW();
  pushW( (int) b);
 
  The following example is one that generates this instruction:
 
  w = (int) b;             /* generates a CvtBW */
 
 
                                     --
 
.context CvtuLT
.context CvtWT
.context CvtuWT
.context CvtLT
.context @L801a
:z3
                                              \aUp\vadvisor.hlp!h.contents\v \aContents\vadvisor.hlp!h.contents\v \aIndex\vadvisor.hlp!h.index\v \aBack\v!B\v
컴P-Code Instructions컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 
:nCvt<t>T
  Syntax
 
  Cvt<t>T
 
  /* Convert integer to temp-real. */
 
  Possible Instructions
 
  CvtLT, CvtuLT, CvtWT, CvtuWT
 
  See: \aP-Code Data Types\v@L8070\v
 
  Description
 
  Convert the signed or unsigned integer or long integer value on the top
  of the evaluation stack to a temp-real on the floating point stack.
  CvtLT is used for signed longs, CvtuLT is used for unsigned longs, CvtWL
  is used for signed words, and CvtuWL is used for unsigned words.
 
  Pseudocode equivalent:
 
  <t> = Pop<t>();
  Push<t>((treal)<t>);
 
  This is done when converting an integer type into any floating point
  type. For example:
 
  long l = 10L;
  float f;
  f = (float) l;      /* generates CvtLT */
 
 
                                     --
 
.context CvtWL
.context @L801b
:z3
                                              \aUp\vadvisor.hlp!h.contents\v \aContents\vadvisor.hlp!h.contents\v \aIndex\vadvisor.hlp!h.index\v \aBack\v!B\v
컴P-Code Instructions컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 
:nCvtWL
  Syntax
 
  CvtWL
 
  /* Convert word to long. */
 
  Description
 
  Pops the top word off the stack and signed extends it to a long value.
  The long value is then pushed onto the stack.
 
  Pseudocode equivalent:
 
  PushL((long) PopW());
 
 
                                     --
 
.context CvtWuQb
.context @L801c
:z3
                                              \aUp\vadvisor.hlp!h.contents\v \aContents\vadvisor.hlp!h.contents\v \aIndex\vadvisor.hlp!h.index\v \aBack\v!B\v
컴P-Code Instructions컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 
:nCvtWuQ<n>
  Syntax
 
  CvtWuQ<n>
 
  /* Convert word to unsigned bit field. */
 
  Possible Instructions
 
  CvtWuQb
 
  Description
 
  Used to extract an unsigned bit field from the top word of the stack.
  The top word is popped, shifted, and masked, and the resulting value is
  pushed as a word back onto the stack. The one-byte parameter <n>
  specifies the shift count (0-15) and the width (minus 1) of the bit
  field (0-15).
 
  See also: \aCvtWQb\v@L801d\v
 
  Pseudocode equivalent:
 
  unsigned int w, width, shift
  width = (<n> >> 4) + 1;
  shift = <n> & 0xf;
  w = PopW();
  w >>= shift;
  w &= (2 ** width) - 1;
  PushW(w);
 
  Assigning a variable to the value of a structure's bit field will
  generate this instruction, as in
 
  typedef struct
  {
  unsigned uT1:2;
  unsigned uT2:4;
  unsigned uT3:8;
  } BF;
  BF *pbf;
 
  pbf->uT1 = 55;
  pbf->uT2 = pbf->uT1;     /* generate CvtWuQ<b> */
 
 
                                     --
 
.context CvtWQb
.context @L801d
:z3
                                              \aUp\vadvisor.hlp!h.contents\v \aContents\vadvisor.hlp!h.contents\v \aIndex\vadvisor.hlp!h.index\v \aBack\v!B\v
컴P-Code Instructions컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 
:nCvtWQ<n>
  Syntax
 
  CvtWQ<n>
 
  /* Convert word to signed bit field. */
 
  Possible Instructions
 
  CvtWQb
 
  Description
 
  Used to extract a signed bit field from the top word of the stack. The
  top word is popped, shifted, and masked. The bit field is then
  sign-extended to a word value and pushed back onto the stack.
 
  The one-byte parameter <n> specifies the shift count (0-15) and the
  width (minus 1) of the bit field (0-15).
 
  See: \aCvtWuQb\v@L801c\v
 
 
                                     --
 
.context DecWb
.context DecW1
.context @L801e
:z3
                                              \aUp\vadvisor.hlp!h.contents\v \aContents\vadvisor.hlp!h.contents\v \aIndex\vadvisor.hlp!h.index\v \aBack\v!B\v
컴P-Code Instructions컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 
:nDecW<n>
  Syntax
 
  DecW<n>
 
  /* Decrement top word on stack */
 
  Possible Instructions
 
  DecW1, DecWb
 
  Description
 
  This instruction decrements the top of stack element by <n> and pushes
  the new value onto the stack.
 
  Pseudocode equivalent:
 
  w1 = Pop();
  Push(w1 - <n>);
 
 
                                     --
 
.context DivL
.context DivT
.context DivuL
.context DivuW
.context DivW
.context DivB
.context @L801f
:z3
                                              \aUp\vadvisor.hlp!h.contents\v \aContents\vadvisor.hlp!h.contents\v \aIndex\vadvisor.hlp!h.index\v \aBack\v!B\v
컴P-Code Instructions컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 
:nDiv<t>
  Syntax
 
  Div<t>
 
  /* Divide top two items on stack */
 
  Possible Instructions
 
  DivB, DivL, DivT, DivuL, DivuW, DivW
 
  See: \aP-Code Data Types\v@L8070\v
 
  Description
 
  Pops the two top elements from the stack, does a divide, and then pushes
  the result onto the stack. The result and both operands are of type <t>.
  For integer operands the evaluation stack is used. For floating point
  operands the floating point stack is used.
 
  Pseudocode equivalent:
 
  <t>2 = Pop<t>();
  <t>1 = Pop<t>();
  Push<t>(<t>1 / <t>2);
 
  NOTE: DivW places <t>1 % <t>2 in the temporary p-code register t as a
        side effect.
 
  This instruction is generated by
 
  lT2 / lT1
 
 
                                     --
 
.context DivLWW
.context @L8020
:z3
                                              \aUp\vadvisor.hlp!h.contents\v \aContents\vadvisor.hlp!h.contents\v \aIndex\vadvisor.hlp!h.index\v \aBack\v!B\v
컴P-Code Instructions컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 
:nDivLWW
  Syntax
 
  DivLWW
 
  /* Divide long by word, push word result */
 
  Description
 
  Pops a word and a long from the stack and pushes an integer that results
  from dividing the long value by the word value. The remainder is stored
  in the temporary p-code register t.
 
  Pseudocode equivalent:
 
  w = Pop();
  l = LongPop();
  w2 = (int)(l / w);
  Push(w2);
  t = l % w;
 
  This is generated in the following statement:
 
  int w1;
  w1 = (int)(lTest / wTest); /* generates DivLWW */
 
 
                                     --
 
.context DropT
.context DropW
.context @L8021
:z3
                                              \aUp\vadvisor.hlp!h.contents\v \aContents\vadvisor.hlp!h.contents\v \aIndex\vadvisor.hlp!h.index\v \aBack\v!B\v
컴P-Code Instructions컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 
:nDrop<t>
  Syntax
 
  Drop<t>
 
  /* Drop (pop and discard) top item on stack */
 
  Possible Instructions
 
  DropW, DropT
 
  See: \aP-Code Data Types\v@L8070\v
 
  Description
 
  Decrements the stack pointer by the appropriate amount to pop the top
  stack element and discard its value.
 
  Pseudocode equivalent:
 
  Pop<t>();
 
 
                                     --
 
.context Equote
.context @L8022
:z3
                                              \aUp\vadvisor.hlp!h.contents\v \aContents\vadvisor.hlp!h.contents\v \aIndex\vadvisor.hlp!h.index\v \aBack\v!B\v
컴P-Code Instructions컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 
:nEquote
  Syntax
 
  Equote
 
  /* Mark end of quoted region */
 
  Description
 
  Returns from a quote subroutine.
 
  Pseudocode equivalent:
 
  if (pcQuote != 0)
  { pc = pcQuote; pcQuote = 0; }
 
 
                                     --
 
.context Exo
.context @L8023
:z3
                                              \aUp\vadvisor.hlp!h.contents\v \aContents\vadvisor.hlp!h.contents\v \aIndex\vadvisor.hlp!h.index\v \aBack\v!B\v
컴P-Code Instructions컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 
:nExo
  Syntax
 
  Exo
 
  /* Extended opcode prefix */
 
  Description
 
  This indicates that the next opcode in the instruction stream is an
  extended opcode.
 
 
                                     --
 
.context Goto2
.context Goto3
.context Goto4
.context Goto5
.context Gotos
.context Gotow
.context Goto1
.context @L8024
:z3
                                              \aUp\vadvisor.hlp!h.contents\v \aContents\vadvisor.hlp!h.contents\v \aIndex\vadvisor.hlp!h.index\v \aBack\v!B\v
컴P-Code Instructions컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 
:nGoto<n>
  Syntax
 
  Goto<n>
 
  /* Goto offset */
 
  Possible Instructions
 
  Goto1..Goto5, Gotos, Gotow
 
  Description
 
  Performs an unconditional jump, where <n> is a byte displacement. Note
  that the variant can be used for long backward jumps.
 
  pc += <n>;
 
  This instruction can be generated by jumping to a forward label using
  the goto reserved word:
 
  goto OK2;                /* generates GOTO<n> */
  .
  .
  OK2:
 
 
                                     --
 
.context Gotonb
.context @L8025
:z3
                                              \aUp\vadvisor.hlp!h.contents\v \aContents\vadvisor.hlp!h.contents\v \aIndex\vadvisor.hlp!h.index\v \aBack\v!B\v
컴P-Code Instructions컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 
:nGoton<n>
  Syntax
 
  Goton<n>
 
  /* Short jump backwards */
 
  Possible Instructions
 
  Gotonb
 
  Description
 
  Performs an unconditional backward jump. In this case, <n> is the
  distance to the jump target.
 
  Pseudocode equivalent:
 
  pc -= <n>;
 
  This instruction can be generated by jumping to a label behind the
  current location:
 
  OK2:
  .
  .
  goto OK2;                /* generates Goton<n> */
 
 
                                     --
 
.context IncW2
.context IncW3
.context IncW4
.context IncW6
.context IncW8
.context IncW10
.context IncW12
.context IncW14
.context IncW16
.context IncWb
.context IncW1
.context @L8026
:z3
                                              \aUp\vadvisor.hlp!h.contents\v \aContents\vadvisor.hlp!h.contents\v \aIndex\vadvisor.hlp!h.index\v \aBack\v!B\v
컴P-Code Instructions컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 
:nInc<t><n>
  Syntax
 
  Inc<t><n>
 
  /* Increment top element on stack */
 
  Possible Instructions
 
  IncW1...IncW4, IncW6, IncW8, IncW10, IncW12, IncW14, IncW16, IncWb
 
  See: \aP-Code Data Types\v@L8070\v
       \aP-Code Operands\v@L8071\v
 
  Description
 
  Increment the top element of type <t> on the stack by <n>. If <n> is not
  specified, the increment is 1.
 
  Pseudocode equivalent:
 
  <t> = Pop<t>();
  Push<t>(<t> + <n>);
 
  For example:
 
  int w1, w2;
  w1 = w2 + 2;        /* generates IncW2 */
 
 
                                     --
 
.context IncfBw
.context IncfW0
.context IncfW1
.context IncfW2
.context IncfW3
.context IncfW4
.context IncfW5
.context IncfW6
.context IncfW7
.context IncfW8
.context IncfWb
.context IncfWw
.context IncfBb
.context @L8027
:z3
                                              \aUp\vadvisor.hlp!h.contents\v \aContents\vadvisor.hlp!h.contents\v \aIndex\vadvisor.hlp!h.index\v \aBack\v!B\v
컴P-Code Instructions컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 
:nIncf<t><n>
  Syntax
 
  Incf<t><n>
 
  /* Increment frame variable by 1 */
 
  Possible Instructions
 
  IncfBb, IncfBw, IncfW0...IncfW8, IncfWb, IncfWw
 
  See: \aP-Code Data Types\v@L8070\v
       \aP-Code Operands\v@L8071\v
 
  Description
 
  Increment the frame variable by 1, while the preincremented value is
  stored in the p-code temporary register t.
 
  Pseudocode equivalent:
 
  // when <n> is a implied number #
 
  t = *(bp - fs - (2 *  #));
  *(bp - fs - (2 * #))++;
 
  // when <n> is a byte <b>
 
  t = *(bp + (2 * (<b> | 0xff00)));
  *(bp + (2 * (<b> | 0xff00)))++;
 
  // when <n> is a word w
 
  t = *(bp + (2 * w));
  *(bp + (2 * w))++;
 
  Using the increment operator (++) in C generates this instruction.
 
 
                                     --
 
.context IncfBwb
.context IncfWbb
.context IncfWbw
.context IncfWwb
.context IncfWww
.context IncfLbb
.context IncfLbw
.context IncfLbl
.context IncfLwb
.context IncfLww
.context IncfLwl
.context IncfFbb
.context IncfFbw
.context IncfFwb
.context IncfHbb
.context IncfHbw
.context IncfHwb
.context IncfHww
.context IncfBbb
.context @L8028
:z3
                                              \aUp\vadvisor.hlp!h.contents\v \aContents\vadvisor.hlp!h.contents\v \aIndex\vadvisor.hlp!h.index\v \aBack\v!B\v
컴P-Code Instructions컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 
:nIncf<t><n><m>
  Syntax
 
  Incf<t><n><m>
 
  /* Increment frame variable by specified value */
 
  Possible Instructions
 
  IncfBbb, IncfBwb, IncfWbb, IncfWbw, IncfWwb, IncfWww, IncfLbb, IncfLbw,
  IncfLbl, IncfLwb, IncfLww, IncfLwl, IncfFbb, IncfFbw, IncfFwb, IncfHbb,
  IncfHbw, IncfHwb, IncfHww
 
  See: \aP-Code Data Types\v@L8070\v
       \aP-Code Operands\v@L8071\v
 
  Description
 
  Increment a frame variable by <m>, while the preincremented value is
  stored in the p-code temporary register t.
 
  Pseudocode equivalent:
 
  // when <n> is a byte <b>
 
  t = *(bp + (2 * (<b> | 0xff00));
  *(bp + (2 * (<b> | 0xff00)) += <m>;
 
  // when <n> is a word w
 
  t = *(bp + (2 * w));
  *(bp + (2 * w)) += <m>;
 
  Using the increment operator (+=) in C generates this instruction.
 
 
                                     --
 
.context IncgBwb
.context IncgWbb
.context IncgWbw
.context IncgWwb
.context IncgWww
.context IncgLbb
.context IncgLbw
.context IncgLbl
.context IncgLwb
.context IncgLww
.context IncgLwl
.context IncgFbb
.context IncgFbw
.context IncgFwb
.context IncgHbb
.context IncgHbw
.context IncgHwb
.context IncgHww
.context IncgBbb
.context @L8029
:z3
                                              \aUp\vadvisor.hlp!h.contents\v \aContents\vadvisor.hlp!h.contents\v \aIndex\vadvisor.hlp!h.index\v \aBack\v!B\v
컴P-Code Instructions컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 
:nIncg<t><n><m>
  Syntax
 
  Incg<t><n><m>
 
  /* Increment global variable by specified value */
 
  Possible Instructions
 
  IncgBbb, IncgBwb, IncgWbb, IncgWbw, IncgWwb, IncgWww, IncgLbb, IncgLbw,
  IncgLbl, IncgLwb, IncgLww, IncgLwl, IncgFbb, IncgFbw, IncgFwb, IncgHbb,
  IncgHbw, IncgHwb, IncgHww
 
  See: \aP-Code Data Types\v@L8070\v
       \aP-Code Operands\v@L8071\v
 
  Description
 
  Increment the near global variables by <m>, while the preincremented
  value is stored in t. The address of the global is found relative to
  pspi, which is a pointer to an internal p-code table of segment-specific
  references.
 
  t = **(pspi + <n>);
  **(pspi + <n>) + <m>;
 
  Using the increment operator in C generates this instruction. For
  example,
 
  wNG+=2
 
  If the index <n> is specified as an immediate operand, the global
  variable address can be either near or far. The decision is made by the
  compiler and implemented at run time using a range check on the index.
 
 
                                     --
 
.context Int3
.context @L802a
:z3
                                              \aUp\vadvisor.hlp!h.contents\v \aContents\vadvisor.hlp!h.contents\v \aIndex\vadvisor.hlp!h.index\v \aBack\v!B\v
컴P-Code Instructions컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 
:nInt3
  Syntax
 
  Int3
 
  /* Software interrupt for the p-code machine */
 
  Description
 
  Acts as the software interrupt for the p-code machine, and is reserved
  for use by the debugger. It is always assigned the opcode of 0xCC.
 
 
                                     --
 
.context JeqWb
.context JeqW3
.context @L802b
:z3
                                              \aUp\vadvisor.hlp!h.contents\v \aContents\vadvisor.hlp!h.contents\v \aIndex\vadvisor.hlp!h.index\v \aBack\v!B\v
컴P-Code Instructions컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 
:nJeqW<n>
  Syntax
 
  JeqW<n>
 
  /* Branch on Equal */
 
  Possible Instructions
 
  JeqW3, JeqWb
 
  See: \aP-Code Operands\v@L8071\v
 
  Description
 
  Pops two elements off the stack and checks to see if they are equal. If
  the two values are equal, control jumps to location S. Otherwise
  processing continues with the next instruction.
 
  if(popW() == popW())
  pc += <n>;
 
  The instruction is produced in the following example:
 
  if (wTest != 25)              /* generates JeqW<n> */
 
 
                                     --
 
.context JgeWb
.context JgeW3
.context @L802c
:z3
                                              \aUp\vadvisor.hlp!h.contents\v \aContents\vadvisor.hlp!h.contents\v \aIndex\vadvisor.hlp!h.index\v \aBack\v!B\v
컴P-Code Instructions컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 
:nJgeW<n>
  Syntax
 
  JgeW<n>
 
  /* Branch on Greater or Equal */
 
  Possible Instructions
 
  JgeW3, JgeWb
 
  See: \aP-Code Operands\v@L8071\v
 
  Description
 
  Pops two values off the stack and checks to see if the second is greater
  than or equal to the first. If it is, control jumps to location S.
  Otherwise processing continues with the next instruction.
 
  Pseudocode equivalent:
 
  w2 = popW();
  w1 = popW();
  if (w1 >= w2)
  pc += <n>;
 
  The following generates this instruction:
 
  if (w1 < w2)                  /* generates JgeW<n> */
 
 
                                     --
 
.context JgtWb
.context JgtW3
.context @L802d
:z3
                                              \aUp\vadvisor.hlp!h.contents\v \aContents\vadvisor.hlp!h.contents\v \aIndex\vadvisor.hlp!h.index\v \aBack\v!B\v
컴P-Code Instructions컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 
:nJgtW<n>
  Syntax
 
  JgtW<n>
 
  /* Branch on Greater Than */
 
  Possible Instructions
 
  JgtW3, JgtWb
 
  See: \aP-Code Operands\v@L8071\v
 
  Description
 
  Pops two values off the stack and checks to see if the second is greater
  than the first. If it is, control jumps to location S. Otherwise
  processing continues with the next instruction.
 
  Pseudocode equivalent:
 
  w2 = popW();
  w1 = popW();
  if (w1 > w2)
 
  // pc = p-code instruction pointer
 
  pc += <n>;
 
  The following generates this instruction:
 
  if (w1 <= w2)                 /* generates JgtW<n> */
 
 
                                     --
 
.context JleWb
.context JleW3
.context @L802e
:z3
                                              \aUp\vadvisor.hlp!h.contents\v \aContents\vadvisor.hlp!h.contents\v \aIndex\vadvisor.hlp!h.index\v \aBack\v!B\v
컴P-Code Instructions컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 
:nJleW<n>
  Syntax
 
  JleW<n>
 
  /* Branch on Less than or Equal */
 
  Possible Instructions
 
  JleW3, JleWb
 
  See: \aP-Code Operands\v@L8071\v
 
  Description
 
  Pops two values off the stack and checks to see if the second is less
  than or equal to the first. If it is, control jumps to location S.
  Otherwise processing continues with the next instruction.
 
  Pseudocode equivalent:
 
  w2 = popW();
  w1 = popW();
  if (w1 <= w2)
  pc += <n>;
 
  A comparison such as the following generates this instruction:
 
  if (w1 > w2)                  /* generates JleW<n> */
 
 
                                     --
 
.context JltWb
.context JltW3
.context @L802f
:z3
                                              \aUp\vadvisor.hlp!h.contents\v \aContents\vadvisor.hlp!h.contents\v \aIndex\vadvisor.hlp!h.index\v \aBack\v!B\v
컴P-Code Instructions컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 
:nJltW<n>
  Syntax
 
  JltW<n>
 
  /* Branch on Less Than */
 
  Possible Instructions
 
  JltW3, JltWb
 
  See: \aP-Code Operands\v@L8071\v
 
  Description
 
  Pops two values off the stack and checks to see if the second is less
  than the first. If it is, control jumps to location S. Otherwise
  processing continues with the next instruction.
 
  Pseudocode equivalent:
 
  w2 = popW();
  w1 = popW();
  if (w1 < w2)
  pc += <n>;
 
  This can be generated by the following:
 
  if (w1 >= w2)                 /* generates JltW<n> */
 
 
                                     --
 
.context JneW2
.context JneW3
.context JneW4
.context JneW5
.context JneWb
.context JneW1
.context @L8030
:z3
                                              \aUp\vadvisor.hlp!h.contents\v \aContents\vadvisor.hlp!h.contents\v \aIndex\vadvisor.hlp!h.index\v \aBack\v!B\v
컴P-Code Instructions컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 
:nJneW<n>
  Syntax
 
  JneW<n>
 
  /* Branch on Not Equal */
 
  Possible Instructions
 
  JneW1...JneW5, JneWb
 
  See: \aP-Code Operands\v@L8071\v
 
  Description
 
  Pops two elements off the stack and checks to see whether or not they
  are equal. If they are not equal, control jumps ahead <n> bytes, or to
  location S. Otherwise execution continues with the next instruction.
 
  Pseudocode equivalent:
 
  If (popW() != popW())
  pc += <n>;
 
  This instruction is generated by the following example:
 
  if (wTest1 == wTest2)         /* generates JneW<n> */
 
 
                                     --
 
.context JnzW2
.context JnzW3
.context JnzW4
.context JnzW5
.context JnzWb
.context JnzW1
.context @L8031
:z3
                                              \aUp\vadvisor.hlp!h.contents\v \aContents\vadvisor.hlp!h.contents\v \aIndex\vadvisor.hlp!h.index\v \aBack\v!B\v
컴P-Code Instructions컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 
:nJnzW<n>
  Syntax
 
  JnzW<n>
 
  /* Branch on Not Zero */
 
  Possible Instructions
 
  JnzW1...JnzW5, JnzWb
 
  See: \aP-Code Operands\v@L8071\v
 
  Description
 
  Pops the top element off the stack and checks whether or not it is equal
  to zero. If it is not equal to zero, control jumps ahead <n> bytes or to
  location S. Otherwise control continues with the next instruction.
 
  Pseudocode equivalent:
 
  if (popW() != 0)
  pc += <n>;
 
  This instruction is generated by the following example:
 
  if (wTest == 0)               /* generates JnzW<n> */
 
 
                                     --
 
.context JzrW2
.context JzrW3
.context JzrW4
.context JzrW5
.context JzrW6
.context JzrW7
.context JzrW8
.context JzrWb
.context JzrW1
.context @L8032
:z3
                                              \aUp\vadvisor.hlp!h.contents\v \aContents\vadvisor.hlp!h.contents\v \aIndex\vadvisor.hlp!h.index\v \aBack\v!B\v
컴P-Code Instructions컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 
:nJzrW<n>
  Syntax
 
  JzrW<n>
 
  /* Branch on Zero */
 
  Possible Instructions
 
  JzrW1...JzrW8, JzrWb
 
  See: \aP-Code Operands\v@L8071\v
 
  Description
 
  Pops the top element off the stack and checks to see if it is equal to
  zero. If it is equal to zero, control jumps ahead <n> bytes or to
  location S. Otherwise execution continues with the next instruction.
 
  Pseudocode equivalent:
 
  if (popW() == 0)
  pc += <n>;
 
  The instruction is generated in the condition below:
 
  if (wTest != 0)               /* generates JzrW<n> */
 
 
                                     --
 
.context LdcW1
.context LdcW2
.context LdcW3
.context LdcW4
.context LdcW5
.context LdcW6
.context LdcW7
.context LdcW8
.context LdcW9
.context LdcW10
.context LdcWub
.context LdcWm1
.context LdcWw
.context LdcLl
.context LdcD
.context LdcR
.context LdcT
.context LdcW0
.context @L8033
:z3
                                              \aUp\vadvisor.hlp!h.contents\v \aContents\vadvisor.hlp!h.contents\v \aIndex\vadvisor.hlp!h.index\v \aBack\v!B\v
컴P-Code Instructions컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 
:nLdc<t><n>
  Syntax
 
  Ldc<t><n>
 
  /* Push a constant on stack. */
 
  Possible Instructions
 
  LdcW0...LdcW10, LdcWub, LdcWm1, LdcWw, LdcLl, LdcD, LdcR, LdcT
 
  See: \aP-Code Data Types\v@L8070\v
       \aP-Code Operands\v@L8071\v
 
  Description
 
  Loads the constant <n> onto the stack. This is done any time a constant
  is assigned to a variable. For example,
 
  wT = 5
 
  generates a LdcW5.
 
  Pseudocode equivalent:
 
  Push<t>(<n>);
 
 
                                     --
 
.context LdfA1
.context LdfA2
.context LdfA3
.context LdfA4
.context LdfA5
.context LdfA6
.context LdfA7
.context LdfA8
.context LdfA9
.context LdfAb
.context LdfAw
.context LdfA0
.context @L8034
:z3
                                              \aUp\vadvisor.hlp!h.contents\v \aContents\vadvisor.hlp!h.contents\v \aIndex\vadvisor.hlp!h.index\v \aBack\v!B\v
컴P-Code Instructions컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 
:nLdfA<n>
  Syntax
 
  LdfA<n>
 
  /* Load Address of Frame Variable */
 
  Possible Instructions
 
  LdfA0...LdfA9, LdfAb, LdfAw
 
  See: \aP-Code Operands\v@L8071\v
 
  Description
 
  Loads the near address of the specified local variable or function
  parameter onto the stack. A negative value for <n> addresses a local
  variable, and a positive value addresses a function parameter.
 
  NOTE: When LdfAb is generated, the byte parameter is assumed to be a
        negative value. Thus, it refers only to local variables.
 
  // when <n> is a implied number #
 
  PushW(bp - fs - (2 *  #));
 
  // when <n> is a byte <b>
 
  PushW(bp + (2 * (<b> | 0xff00)));
 
  // when <n> is a word w
 
  PushW(bp + (2 * w));
 
  The instruction could be generated by assigning a pointer to a
  variable's address. For example,
 
  lp1 = &lTest;            /* generates LdfA<n> */
 
 
                                     --
 
.context LdfBw
.context LdfDw
.context LdfRw
.context LdfTw
.context LdfW0
.context LdfW1
.context LdfW2
.context LdfW3
.context LdfW4
.context LdfW5
.context LdfW6
.context LdfW7
.context LdfW8
.context LdfW9
.context LdfW10
.context LdfW11
.context LdfW12
.context LdfW13
.context LdfW14
.context LdfW15
.context LdfW16
.context LdfWb
.context LdfWw
.context LdfLb
.context LdfLw
.context LdfBb
.context @L8035
:z3
                                              \aUp\vadvisor.hlp!h.contents\v \aContents\vadvisor.hlp!h.contents\v \aIndex\vadvisor.hlp!h.index\v \aBack\v!B\v
컴P-Code Instructions컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 
:nLdf<t><n>
  Syntax
 
  Ldf<t><n>
 
  /* Load frame relative item */
 
  Possible Instructions
 
  LdfBb, LdfBw, LdfDw, LdfRw, LdfTw, LdfW0...LdfW16, LdfWb, LdfWw, LdfLb,
  LdfLw
 
  See: \aP-Code Data Types\v@L8070\v
       \aP-Code Operands\v@L8071\v
 
  Description
 
  Loads the value of the specified local variable or function parameter
  onto the stack. A negative value for <n> addresses a local variable, and
  a positive value addresses a function parameter.
 
  NOTE: When Ldf<t>b is generated, the byte parameter is assumed to be a
        negative value. Thus, it refers only to local variables.
 
  // when <n> is a implied number #
 
  Push<t>(bp - fs - (2 *  #));
 
  // when <n> is a byte <b>
 
  Push<t>(bp + (2 * (<b> | 0xff00)));
 
  // when <n> is a word w
 
  Push<t>(bp + (2 * w));
 
 
                                     --
 
.context LdgA1
.context LdgA2
.context LdgA3
.context LdgA4
.context LdgAb
.context LdgA0
.context @L8036
:nLdgA<n>
:z3
                                              \aUp\vadvisor.hlp!h.contents\v \aContents\vadvisor.hlp!h.contents\v \aIndex\vadvisor.hlp!h.index\v \aBack\v!B\v
컴P-Code Instructions컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 
  Syntax
 
  LdgA<n>
 
  /* Push address of the global variable onto the stack */
 
  Possible Instructions
 
  LdgA0...LdgA4, LdgAb
 
  See: \aP-Code Operands\v@L8071\v
 
  Description
 
  Load the near address of the specified global variable onto the stack.
  The global variable specified is relative to an internal p-code table of
  function references (for LngdA0...LdngA4) or an internal table of
  segment references (for LdgAb).
 
  This can be generated by assigning a pointer to a global variable. For
  example,
 
  pTest = &wGlobal
 
  Pseudocode equivalent:
 
  // pfh = pointer-to-function: an internal p-code table
  //  of references
  PushW(*(pfh + <n>));
 
  OR
 
  // pspi = pointer-to-segment: an internal p-code table
  // of references
  PushW(*(pspi + <n>));
 
  If the index <n> is specified as an immediate operand, then the global
  variable address may be near or far. This results in either one or two
  words on the stack.
 
  The decision is made by the compiler and is implemented at run time
  using a range check on the index.
 
 
                                     --
 
.context LdgW1
.context LdgW2
.context LdgW3
.context LdgW4
.context LdgW5
.context LdgW6
.context LdgW7
.context LdgW8
.context LdgW9
.context LdgW10
.context LdgW11
.context LdgW12
.context LdgW13
.context LdgW14
.context LdgW15
.context LdgWb
.context LdgLb
.context LdgW0
.context @L8037
:z3
                                              \aUp\vadvisor.hlp!h.contents\v \aContents\vadvisor.hlp!h.contents\v \aIndex\vadvisor.hlp!h.index\v \aBack\v!B\v
컴P-Code Instructions컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 
:nLdg<t><n>
  Syntax
 
  Ldg<t><n>
 
  /* Push global variable on stack */
 
  Possible Instructions
 
  LdgW0...LdgW15, LdgWb, LdgLb
 
  See: \aP-Code Data Types\v@L8070\v
       \aP-Code Operands\v@L8071\v
 
  Description
 
  Loads the value of the specified global variable onto the stack. The
  address of the global is found relative to an internal p-code table of
  function references (for Ldg<t>#) or segment references (for Ldg<t>b).
  Using any global variable will generate this instruction:
 
  wT = wGlobal
 
  Pseudocode equivalent:
 
  //  pfh = pointer-to-function: an internal p-code table
  //  of references
  Push(**(pfh + <n>));
 
  OR
 
  //  pspi = pointer-to-segment: an internal p-code table
  //  of references
  Push(**(pspi + n));
 
  If the index <n> is specified as an immediate operand, then the global
  variable address can be either near or far.
 
  The decision is made by the compiler, and implemented at run time using
  a range check on the index.
 
 
                                     --
 
.context LdifWb
.context LdifLb
.context LdifR
.context LdifD
.context LdifT
.context LdifBb
.context @L8038
:z3
                                              \aUp\vadvisor.hlp!h.contents\v \aContents\vadvisor.hlp!h.contents\v \aIndex\vadvisor.hlp!h.index\v \aBack\v!B\v
컴P-Code Instructions컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 
:nLdif<t><n>
  Syntax
 
  Ldif<t><n>
 
  /* Load indirect from far pointer */
 
  Possible Instructions
 
  LdifBb, LdifWb, LdifLb, LdifR, LdifD, LdifT
 
  See: \aP-Code Data Types\v@L8070\v
       \aP-Code Operands\v@L8071\v
 
  Description
 
  Loads an indirect value of type <t> onto the stack. The top two words on
  the stack are taken to be a far pointer. The increment <n> is used to
  address a field in a data structure.
 
  Pseudocode equivalent:
 
  lp = (char far *)PopL() + <n>;
  Push<t>(*lp);
 
  This statement can be generated during a comparison involving a far
  pointer, as follows:
 
  *lpw = 5;
  if (*lpw != 5)           /* generates LdifWb */
 
 
                                     --
 
.context LdifoW
.context LdifoL
.context LdifoB
.context @L8039
:z3
                                              \aUp\vadvisor.hlp!h.contents\v \aContents\vadvisor.hlp!h.contents\v \aIndex\vadvisor.hlp!h.index\v \aBack\v!B\v
컴P-Code Instructions컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 
:nLdifo<t>
  Syntax
 
  Ldifo<t>
 
  /* Load indrect far item with scaled offset */
 
  Possible Instructions
 
  LdifoB, LdifoW, LdifoL
 
  See: \aP-Code Data Types\v@L8070\v
 
  Description
 
  Reads an item of type <t> from memory using the far pointer and a scaled
  offset popped from the stack. It then pushes the item onto the stack.
 
  Pseudocode equivalent:
 
  off = PopW() * sizeof(<t>);
  lp<t> = PopL();
  PushT(*(lp<t> + off));
 
 
                                     --
 
.context LdiftW
.context LdiftB
.context @L803a
:z3
                                              \aUp\vadvisor.hlp!h.contents\v \aContents\vadvisor.hlp!h.contents\v \aIndex\vadvisor.hlp!h.index\v \aBack\v!B\v
컴P-Code Instructions컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 
:nLdift<t>
  Syntax
 
  Ldift<t>
 
  /* Load item indirect far through t register */
 
  Possible Instructions
 
  LdiftB, LdiftW
 
  See: \aP-Code Data Types\v@L8070\v
 
  Description
 
  Loads an indirect value through the p-code temporary register t.
 
  Pseudocode equivalent:
 
  Push<t>(*t);
 
  This instruction is generated by statements such as the following:
 
  rgw[3] = *lpshort++;     /* generates LdiftW  */
 
 
                                     --
 
.context LdihoW
.context LdihoB
.context @L803b
:z3
                                              \aUp\vadvisor.hlp!h.contents\v \aContents\vadvisor.hlp!h.contents\v \aIndex\vadvisor.hlp!h.index\v \aBack\v!B\v
컴P-Code Instructions컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 
:nLdiho<t>
  Syntax
 
  Ldiho<t>
 
  /* Load indrect huge item with scaled offset */
 
  Possible Instructions
 
  LdihoB, LdihoW
 
  See: \aP-Code Data Types\v@L8070\v
 
  Description
 
  Reads an item of type <t> from memory using the huge pointer and a
  scaled offset popped from the stack. It then pushes the item onto the
  stack.
 
  Pseudocode equivalent:
 
  off = PopW() * sizeof(<t>);
  hp<t> = PopL();
  PushT(*(hp<t> + off));
 
 
                                     --
 
.context LdinB1
.context LdinB2
.context LdinB3
.context LdinB4
.context LdinBb
.context LdinD
.context LdinW0
.context LdinW1
.context LdinW2
.context LdinW3
.context LdinW4
.context LdinW5
.context LdinW6
.context LdinW7
.context LdinWb
.context LdinL0
.context LdinLb
.context LdinR
.context LdinT
.context LdinB0
.context @L803c
:z3
                                              \aUp\vadvisor.hlp!h.contents\v \aContents\vadvisor.hlp!h.contents\v \aIndex\vadvisor.hlp!h.index\v \aBack\v!B\v
컴P-Code Instructions컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 
:nLdin<t><n>
  Syntax
 
  Ldin<t><n>
 
  /* Load indirect using near pointer. */
 
  Possible Instructions
 
  LdinB0..LdinB4, LdinBb, LdinD, LdinW0...LdinW7, LdinWb, LdinL0, LdinLb,
  LdinR, LdinT
 
  See: \aP-Code Data Types\v@L8070\v
       \aP-Code Operands\v@L8071\v
 
  Description
 
  Loads an indirect item of type <t> onto the stack. The word on the stack
  is taken to be a word pointer, and the increment <n> can be used to
  address a field in a data structure.
 
  Pseudocode equivalent:
 
  p<t> = PopW() + sizeof(<t>) * <n>;
  Push<t>(*p<t>);
 
  Comparing a word pointer to another value is one way to produce the
  LdinW<n> instruction:
 
  *pw = 8;
  if (*pw != 8)            /* generates LdinW<n> */
 
 
                                     --
 
.context LdinoW
.context LdinoL
.context LdinoB
.context @L803d
:z3
                                              \aUp\vadvisor.hlp!h.contents\v \aContents\vadvisor.hlp!h.contents\v \aIndex\vadvisor.hlp!h.index\v \aBack\v!B\v
컴P-Code Instructions컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 
:nLdino<t>
  Syntax
 
  Ldino<t>
 
  /* Load indrect item with scaled offset */
 
  Possible Instructions
 
  LdinoB, LdinoW, LdinoL
 
  See: \aP-Code Data Types\v@L8070\v
 
  Description
 
  Reads an item of type <t> from memory using the near pointer and a
  scaled offset popped from the stack. It then pushes the item onto the
  stack.
 
  Pseudocode equivalent:
 
  off = PopW() * sizeof(<t>);
  p<t> = PopW();
  PushT(*(p<t> + off));
 
 
                                     --
 
.context LdintB
.context LdintW
.context LdintA
.context @L803e
:z3
                                              \aUp\vadvisor.hlp!h.contents\v \aContents\vadvisor.hlp!h.contents\v \aIndex\vadvisor.hlp!h.index\v \aBack\v!B\v
컴P-Code Instructions컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 
:nLdint<t>
  Syntax
 
  Ldint<t>
 
  /* Load item indirect near through t register */
 
  Possible Instructions
 
  LdintA, LdintB, LdintW
 
  See: \aP-Code Data Types\v@L8070\v
 
  Description
 
  Loads an indirect value through the p-code temporary register t.
 
  Push<t>(*t);
 
  This is generated by a statement such as the following:
 
  rgw[3] = *pshort++;      /* generates LdintW  */
 
 
                                     --
 
.context LdixWb
.context @L803f
:z3
                                              \aUp\vadvisor.hlp!h.contents\v \aContents\vadvisor.hlp!h.contents\v \aIndex\vadvisor.hlp!h.index\v \aBack\v!B\v
컴P-Code Instructions컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 
:nLdixWb
  Syntax
 
  LdixWb
 
  /* Push the word at *(this + offset) */
 
  Description
 
  Pushes the word at *(this + offset). The byte after the opcode
  contains:
 
       bit 7: 0 if near, 1 if far
       bits 0-6: signed offset/2
 
  The "this" pointer is fetched from [bp+6] as a word or longword
  (depending on whether the class is near or far, as specified in bit 7).
 
 
                                     --
 
.context LdixLb
.context @L8040
:z3
                                              \aUp\vadvisor.hlp!h.contents\v \aContents\vadvisor.hlp!h.contents\v \aIndex\vadvisor.hlp!h.index\v \aBack\v!B\v
컴P-Code Instructions컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 
:nLdixLb
  Syntax
 
  LdixLb
 
  /* Push the long at *(this + offset) */
 
  Description
 
  Pushes the long at *(this + offset).
 
  See \aLdixWb\v@L803f\v for more details.
 
 
                                     --
 
.context LdpW1
.context LdpW2
.context LdpW3
.context LdpWb
.context LdpLb
.context LdpW0
.context @L8041
:z3
                                              \aUp\vadvisor.hlp!h.contents\v \aContents\vadvisor.hlp!h.contents\v \aIndex\vadvisor.hlp!h.index\v \aBack\v!B\v
컴P-Code Instructions컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 
:nLdp<t><n>
  Syntax
 
  Ldp<t><n>
 
  /* Load parameter */
 
  Possible Instructions
 
  LdpW0...LdpW3, LdpWb, LdpLb
 
  See: \aP-Code Data Types\v@L8070\v
       \aP-Code Operands\v@L8071\v
 
  Description
 
  Loads the value of the function parameter specified in <n> onto the
  stack.
 
 
                                     --
 
.context Ldt<t>
.context @L8042
:z3
                                              \aUp\vadvisor.hlp!h.contents\v \aContents\vadvisor.hlp!h.contents\v \aIndex\vadvisor.hlp!h.index\v \aBack\v!B\v
컴P-Code Instructions컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 
:nLdt<t>
  Syntax
 
  Ldt<t>
 
  See: \aP-Code Data Types\v@L8070\v
 
  /* Load t register item of type <t> onto the stack. */
 
  Description
 
  Loads the value of the p-code temporary register t onto the stack.
 
  Pseudocode equivalent:
 
  Push<t>(t);
 
  Post-incrementing a pointer is one way to generate this instruction:
 
  int w1, w2;
  w2 =  w1++;         /* generates LdtW */
 
 
                                     --
 
.context MulW
.context MulT
.context MulL
.context @L8043
:z3
                                              \aUp\vadvisor.hlp!h.contents\v \aContents\vadvisor.hlp!h.contents\v \aIndex\vadvisor.hlp!h.index\v \aBack\v!B\v
컴P-Code Instructions컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 
:nMul<t>
  Syntax
 
  Mul<t>
 
  /* Multiply top two items on stack */
 
  Possible Instructions
 
  MulL, MulW, MulT
 
  See: \aP-Code Data Types\v@L8070\v
 
  Description
 
  Pops the two top stack elements, performs a multiply, and pushes the
  result back onto the stack.
 
  Pseudocode equivalent:
 
  <t>2 = Pop<t>();
  <t>1 = Pop<t>();
  Push<t>(<t>1 * <t>2);
 
  Any multiplication of two longs generates this opocde:
 
  lT1 = 3333l;
  lT2 = 9999l;
  lT3 = lT2 * lT1;         /* generates MulL */
 
 
                                     --
 
.context MulWWL
.context @L8044
:z3
                                              \aUp\vadvisor.hlp!h.contents\v \aContents\vadvisor.hlp!h.contents\v \aIndex\vadvisor.hlp!h.index\v \aBack\v!B\v
컴P-Code Instructions컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 
:nMulWWL
  Syntax
 
  MulWWL
 
  /* Multiply top two words and push long result */
 
  Description
 
  Pops two words from the stack, multiplies them, and pushes a long result
  onto the stack.
 
  Pseudocode equivalent:
 
  w2 = PopW();
  w1 = PopW();
  l = w1 * w2;
  PushL(l);
 
  This instruction is generated as follows:
 
  int w1, w2;
  long l;
  l = ((long)w1 * (long)w2); /* generates MulWWL */
 
 
                                     --
 
.context NegW
.context @L8045
:z3
                                              \aUp\vadvisor.hlp!h.contents\v \aContents\vadvisor.hlp!h.contents\v \aIndex\vadvisor.hlp!h.index\v \aBack\v!B\v
컴P-Code Instructions컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 
:nNegW
  Syntax
 
  NegW
 
  /* Negate word (2's complement) */
 
  Description
 
  Negates the top stack element and pushes it back onto the stack.
 
  w1 = popW();
  pushW(-w1);
 
  A simple expression such as
 
  if (-wt1 < 0)
 
  generates the NegW instruction.
 
 
                                     --
 
.context Nop
.context @L8046
:z3
                                              \aUp\vadvisor.hlp!h.contents\v \aContents\vadvisor.hlp!h.contents\v \aIndex\vadvisor.hlp!h.index\v \aBack\v!B\v
컴P-Code Instructions컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 
:nNop
  Syntax
 
  Nop
 
  /* No operation. Must be the opcode value 0x00. */
 
  Description
 
  Inserted to force word alignment of functions in certain cases.
 
 
                                     --
 
.context NotL
.context NotW
.context @L8047
:z3
                                              \aUp\vadvisor.hlp!h.contents\v \aContents\vadvisor.hlp!h.contents\v \aIndex\vadvisor.hlp!h.index\v \aBack\v!B\v
컴P-Code Instructions컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 
:nNot<t>
  Syntax
 
  Not<t>
 
  /* Bitwise logical 'not' on top word of stack or negate word  */
  /* (ones's complement)                                        */
 
  Possible Instructions
 
  NotW, NotL
 
  See: \aP-Code Data Types\v@L8070\v
 
  Description
 
  Pops the top word off the stack, does a one's complement negation of the
  bits in the word, and pushes the resulting word back onto the stack.
 
  Pseudocode equivalent:
 
  w = popW();
  pushW(~w);
 
  The instruction can be generated as follows:
 
  w1 = ~w2;           /* generates NotW */
 
 
                                     --
 
.context OrL
.context OrW
.context @L8048
:z3
                                              \aUp\vadvisor.hlp!h.contents\v \aContents\vadvisor.hlp!h.contents\v \aIndex\vadvisor.hlp!h.index\v \aBack\v!B\v
컴P-Code Instructions컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 
:nOr<t>
  Syntax
 
  Or<t>
 
  /* Bitwise logical 'or' top two words on stack */
 
  Possible Instructions
 
  OrW, OrL
 
  See: \aP-Code Data Types\v@L8070\v
 
  Description
 
  Pops two elements from the stack, performs a logical 'or' on them, and
  pushes the result onto the stack.
 
  Pseudocode equivalent:
 
  <t>2 = Pop<t>();
  <t>1 = Pop<t>();
  Push<t>(<t>1 | <t>2);
 
  This is generated as follows:
 
  wTest1 = 32;
  wTest2 = 256;
  if ((wTest1 | wTest2) != 288) /* generate OrW */
 
 
                                     --
 
.context PopIP<n>
.context @L8049
:z3
                                              \aUp\vadvisor.hlp!h.contents\v \aContents\vadvisor.hlp!h.contents\v \aIndex\vadvisor.hlp!h.index\v \aBack\v!B\v
컴P-Code Instructions컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 
:nPopIP<n>
  Syntax
 
  PopIP<n>
 
  /* Branch indirect through near pointer on top of stack. */
 
  See: \aP-Code Operands\v@L8071\v
 
  Description
 
  Implements the break statement within a switch statement. Prior to
  exection of a Case<t> instruction, a PushIP instruction is issued which
  loads the target of a break statement onto the stack. When a break
  statement is encountered, the value is popped from the stack and loaded
  into the instruction pointer.
 
  Pseudocode equivalent:
 
  IP = PopW();
 
  Example:
 
  switch (w)
  {
  case 1:
  break;    /* generate PopIP */
  }
 
 
                                     --
 
.context PopR
.context @L804a
:z3
                                              \aUp\vadvisor.hlp!h.contents\v \aContents\vadvisor.hlp!h.contents\v \aIndex\vadvisor.hlp!h.index\v \aBack\v!B\v
컴P-Code Instructions컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 
:nPopR
  Syntax
 
  PopR
 
  /* Move floating point value from evaluation stack to floating point */
  /* stack                                                             */
 
  Description
 
  Moves a floating point value onto the floating point stack.
 
  Pseudocode equivalent:
 
  float f;
  f = PopR();
  FpPushT((temp-real) f);
 
 
                                     --
 
.context PopW<n>
.context @L804b
:z3
                                              \aUp\vadvisor.hlp!h.contents\v \aContents\vadvisor.hlp!h.contents\v \aIndex\vadvisor.hlp!h.index\v \aBack\v!B\v
컴P-Code Instructions컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 
:nPopW<n>
  Syntax
 
  PopW<n>
 
  /* Move floating point value from evaluation stack to floating point */
  /* stack                                                             */
 
  Description
 
  Pops <n> words from the stack and store them at the address specified by
  the near pointer on top of stack.
 
  Pseudocode equivalent:
 
  int *pw;
  pw = PopW();
  while (<n>--) *pw++ = PopW();
 
 
                                     --
 
.context PushCS
.context @L804c
:z3
                                              \aUp\vadvisor.hlp!h.contents\v \aContents\vadvisor.hlp!h.contents\v \aIndex\vadvisor.hlp!h.index\v \aBack\v!B\v
컴P-Code Instructions컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 
:nPushCS
  Syntax
 
  PushCS
 
  /* Push contents of CS code segment register onto stack. */
 
  Description
 
  Constructs far pointers to locations in the current code segement.
 
  Pseudocode equivalent:
 
  PushW(CS);
 
 
                                     --
 
.context PushDS
.context @L804d
:z3
                                              \aUp\vadvisor.hlp!h.contents\v \aContents\vadvisor.hlp!h.contents\v \aIndex\vadvisor.hlp!h.index\v \aBack\v!B\v
컴P-Code Instructions컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 
:nPushDS
  Syntax
 
  PushDS
 
  /* Push contents of the p-code DS data segment register onto stack. */
 
  Description
 
  Constructs far pointers to locations in the current p-code data
  segement.
 
  NOTE: The p-code DS register is not neccessarily the same as the
        native-code DS data segment register.
 
  Pseudocode equivalent:
 
  PushW(DS);
 
 
                                     --
 
.context PushD
.context PushT
.context PushR
.context @L804e
:z3
                                              \aUp\vadvisor.hlp!h.contents\v \aContents\vadvisor.hlp!h.contents\v \aIndex\vadvisor.hlp!h.index\v \aBack\v!B\v
컴P-Code Instructions컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 
:nPush<t>
  Syntax
 
  Push<t>
 
  /* Move floating point value from floating point stack onto pcode */
  /* evaluation stack. */
 
  Possible Instructions
 
  PushR, PushD, PushT
 
  See: \aP-Code Data Types\v@L8070\v
 
  Description
 
  Pass floating point arguments to functions.
 
  Pseudocode equivalent:
 
  Push<t>(FpPop<t>());
 
  This instruction is generated by an example like the following:
 
  float f, g;
  foo(f,g);      /* Generates PushR */
 
 
                                     --
 
.context PushIPw
.context PushIPb
.context @L804f
:z3
                                              \aUp\vadvisor.hlp!h.contents\v \aContents\vadvisor.hlp!h.contents\v \aIndex\vadvisor.hlp!h.index\v \aBack\v!B\v
컴P-Code Instructions컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 
:nPushIP<n>
  Syntax
 
  PushIP<n>
 
  /* Push value for instruction pointer onto stack using pc-relative */
  /* address <n>. */
 
  Possible Instructions
 
  PushIPb, PushIPw
 
  See: \aP-Code Operands\v@L8071\v
 
  Description
 
  Implements the switch statement by pushing the target address of a break
  statement. The address is relative to the p-code instruction pointer and
  should be the first instruction following the case jump table.
 
  Pseudocode equivalent:
 
  // pc = p-code instruction pointer
 
  // if <n> is a byte <b>
 
  PushW(pc + (<b> & 0xff00))
 
  // if <n> is a word w
 
  PushW(pc + w)
 
  This instruction is generated by an example like the following:
 
  switch (exp)   /* generates a PushIP */
  {
  case 1:
  break;
  }
 
 
                                     --
 
.context QuoteW
.context Quoteb
.context @L8050
:z3
                                              \aUp\vadvisor.hlp!h.contents\v \aContents\vadvisor.hlp!h.contents\v \aIndex\vadvisor.hlp!h.index\v \aBack\v!B\v
컴P-Code Instructions컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 
:nQuote<n>
  Syntax
 
  Quote<n>
 
  /* Call quoted subroutine. */
 
  Possible Instructions
 
  Quoteb, QuoteW
 
  See: \aP-Code Syntax\v@L806f\v
 
  Description
 
  Quoting, or moving repeated series of instructions to the p-code
  equivalent of a subroutine, is one way p-code reduces executable size.
  The Quote<n> instructions call these quoted subroutines.
 
  Pseudocode equivalent:
 
  pcQuote = pc;
  pc -= <n>;
 
 
                                     --
 
.context RemW
.context RemL
.context RemuW
.context RemuL
.context RemB
.context @L8051
:z3
                                              \aUp\vadvisor.hlp!h.contents\v \aContents\vadvisor.hlp!h.contents\v \aIndex\vadvisor.hlp!h.index\v \aBack\v!B\v
컴P-Code Instructions컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 
:nRem<t>
  Syntax
 
  Rem<t>
 
  /* Remainder of integer division of type <t>. */
 
  Possible Instructions
 
  RemB, RemW, RemL, RemuW, RemuL
 
  See: \aP-Code Data Types\v@L8070\v
 
  Description
 
  Performs integer division on the top two elements and pushes the
  remainder onto the stack.
 
  Pseudocode equivalent:
 
  t2 = Pop<t>();
  t1 = Pop<t>();
  Push<t>(t1 % t2);
 
  This is generated, for instance, in a multiple-variable declaration:
 
  wt1 = wt2 % wt3;         /* generates RemW */
 
 
                                     --
 
.context RepW
.context RepT
.context RepL
.context @L8052
:z3
                                              \aUp\vadvisor.hlp!h.contents\v \aContents\vadvisor.hlp!h.contents\v \aIndex\vadvisor.hlp!h.index\v \aBack\v!B\v
컴P-Code Instructions컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 
:nRep<t>
  Syntax
 
  Rep<t>
 
  /* Replicate top item on the stack */
 
  Possible Instructions
 
  RepL, RepW, RepT
 
  See: \aP-Code Data Types\v@L8070\v
 
  Description
 
  Repeats the latest operand by pushing a copy of the current top-of-stack
  element onto the stack.
 
  Pseudocode equivalent:
 
  Push<t>(Top<t>());
 
  This is produced, for instance, in a multiple variable declaration:
 
  Pseudocode equivalent:
 
  wt1 = wt2 = wt3 = 0;          /* generates RepW */
 
 
                                     --
 
.context Ret
.context @L8053
:z3
                                              \aUp\vadvisor.hlp!h.contents\v \aContents\vadvisor.hlp!h.contents\v \aIndex\vadvisor.hlp!h.index\v \aBack\v!B\v
컴P-Code Instructions컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 
:nRet
  Syntax
 
  Ret
 
  /* Return from function call */
 
  Description
 
  Returns from a function to the caller. The instruction assumes that
  there is a 32-bit return value on the top of the stack. It is up to the
  caller of the function to determine how many of the bytes of the return
  value are valid.
 
  This instruction will also pop parameters off of the stack. The number
  of words of parameters to be popped off is kept in an internal p-code
  table specific to the procedure, or stored in a byte or word following
  the call.
 
  Pseudocode equivalent:
 
  return lTest;                 /* generates Ret */
 
 
                                     --
 
.context SarL
.context SarW
.context @L8054
:z3
                                              \aUp\vadvisor.hlp!h.contents\v \aContents\vadvisor.hlp!h.contents\v \aIndex\vadvisor.hlp!h.index\v \aBack\v!B\v
컴P-Code Instructions컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 
:nSar<t>
  Syntax
 
  Sar<t>
 
  /* Shift Arithmetic Right signed integer */
 
  Possible Instructions
 
  SarW, SarL
 
  See: \aP-Code Data Types\v@L8070\v
 
  Description
 
  Pops two elements from the stack and does an arithmetic right shift,
  shifting the second popped element right by the value of the first
  popped element.
 
  Pseudocode equivalent:
 
  w2 = PopW();
  t1 = Pop<t>();
  Push<t>(t1 >> w2);
 
  This can be generated by the following:
 
  wT = wT1 >> 2;           /* generates SarW */
 
 
                                     --
 
.context SetfBb
.context @L8055
:z3
                                              \aUp\vadvisor.hlp!h.contents\v \aContents\vadvisor.hlp!h.contents\v \aIndex\vadvisor.hlp!h.index\v \aBack\v!B\v
컴P-Code Instructions컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 
:nSetf<t><n>
  Syntax
 
  Setf<t><n>
 
  /* Set frame item (integer) to value 1. */
 
  Possible Instructions
 
  SetfBb
 
  See: \aP-Code Data Types\v@L8070\v
       \aP-Code Operands\v@L8071\v
 
  Description
 
  Sets the specified frame integer variable to the value 1.
 
 
                                     --
 
.context ShlL
.context ShlW
.context @L8056
:z3
                                              \aUp\vadvisor.hlp!h.contents\v \aContents\vadvisor.hlp!h.contents\v \aIndex\vadvisor.hlp!h.index\v \aBack\v!B\v
컴P-Code Instructions컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 
:nShl<t>
  Syntax
 
  Shl<t>
 
  /* Shift Word/Long Logical Left by n bits */
 
  Possible Instructions
 
  ShlW, ShlL
 
  See: \aP-Code Data Types\v@L8070\v
 
  Description
 
  Performs a left shift, popping two elements off of the stack and pushing
  the result onto the stack.
 
  Pseudocode equivalent:
 
  w2 = PopW();
  t1 = Pop<t>();
  Push<t>(t1 << w2);
 
  A left shift is all that is required to generate this instruction:
 
  wTest2 = wTest2 << wTest1;  /* generates ShlW */
 
 
                                     --
 
.context ShlL1
.context ShlW1
.context @L8057
:z3
                                              \aUp\vadvisor.hlp!h.contents\v \aContents\vadvisor.hlp!h.contents\v \aIndex\vadvisor.hlp!h.index\v \aBack\v!B\v
컴P-Code Instructions컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 
:nShl<t>1
  Syntax
 
  Shl<t>1
 
  /* Shift Word Logical Left one bit */
 
  Possible Instructions
 
  ShlW1, ShlL1
 
  See: \aP-Code Data Types\v@L8070\v
 
  Description
 
  Performs a left shift by one. It pops the top stack element off of the
  stack, shifts it left by one, and pushes the new value back onto the
  stack.
 
  Pseudocode equivalent:
 
  Push<t>(Pop<t>() << 1);
 
  Simply perform a left shift by one on a variable to generate this
  instruction:
 
  wTest1 <<= 1;            /* generates ShlW1 */
 
 
                                     --
 
.context ShrL
.context ShrW
.context @L8058
:z3
                                              \aUp\vadvisor.hlp!h.contents\v \aContents\vadvisor.hlp!h.contents\v \aIndex\vadvisor.hlp!h.index\v \aBack\v!B\v
컴P-Code Instructions컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 
:nShr<t>
  Syntax
 
  Shr<t>
 
  /* Shift Word Logical Right by n bits */
 
  Possible Instructions
 
  ShrW, ShrL
 
  See: \aP-Code Data Types\v@L8070\v
 
  Description
 
  Performs a right shift by one. It pops the top stack element off of the
  stack, shifts it right by one, and pushes the new value back onto the
  stack.
 
  Pseudocode equivalent:
 
  u2 = popW();
  u1 = popW();
  pushW(u1 >> u2);
 
  This can be generated as follows:
 
  uTest1 = uTest2 >> 1;    /* generates ShrW */
 
 
                                     --
 
.context SpillTb
.context @L8059
:z3
                                              \aUp\vadvisor.hlp!h.contents\v \aContents\vadvisor.hlp!h.contents\v \aIndex\vadvisor.hlp!h.index\v \aBack\v!B\v
컴P-Code Instructions컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 
:nSpillTb
  Syntax
 
  SpillTb
 
  /* Spill floating point stack to temp area. */
 
  Description
 
  Writes the contents of the floating point stack to memory and clears the
  stack. This is done prior to function calls or to avoid overflow. The
  reverse operation is performed with the UnSpillTb instruction.
 
 
                                     --
 
.context StfBw
.context StfW0
.context StfW1
.context StfW2
.context StfW3
.context StfW4
.context StfW5
.context StfW6
.context StfW7
.context StfW8
.context StfW9
.context StfW10
.context StfW11
.context StfW12
.context StfW13
.context StfWb
.context StfWw
.context StfLb
.context StfLw
.context StfRw
.context StfDw
.context StfTw
.context StfBb
.context @L805a
:z3
                                              \aUp\vadvisor.hlp!h.contents\v \aContents\vadvisor.hlp!h.contents\v \aIndex\vadvisor.hlp!h.index\v \aBack\v!B\v
컴P-Code Instructions컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 
:nStf<t><n>
  Syntax
 
  Stf<t><n>
 
  /* Store value to frame relative address */
 
  Possible Instructions
 
  StfBb, StfBw,  StfW0...StfW13, StfWb, StfWw, StfLb, StfLw, StfRw, StfDw,
  StfTw
 
  See: \aP-Code Data Types\v@L8070\v
       \aP-Code Operands\v@L8071\v
 
  Description
 
  Transfers the value on the stack to the specified frame variable and
  pops the value off of the stack.
 
  Pseudocode equivalent:
 
  // when <n> is a implied number #
 
  *(bp - fs - (2 *  #)) = Pop<t>();
 
  // when <n> is a byte <b>
 
  *(bp + (2 * (<b> | 0xff00))) = Pop<t>();
 
  // when <n> is a word w
 
  *(bp + (2 * w)) = Pop<t>();
 
  Assigning a value to any frame variable will produce this instruction:
 
  w1 = 25;            /* generates STF<n> */
 
 
                                     --
 
.context StfpWb
.context StfpL
.context StfpBb
.context @L805b
:z3
                                              \aUp\vadvisor.hlp!h.contents\v \aContents\vadvisor.hlp!h.contents\v \aIndex\vadvisor.hlp!h.index\v \aBack\v!B\v
컴P-Code Instructions컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 
:nStfp<t><n>
  Syntax
 
  Stfp<t><n>
 
  /* Store value to frame relative address and preserve value on */
  /* the stack                                                   */
 
  Possible Instructions
 
  StfpBb, StfpWb, StfpL
 
  See: \aP-Code Data Types\v@L8070\v
       \aP-Code Operands\v@L8071\v
 
  Description
 
  These instructions transfer the value on the stack to the specified
  frame variable. However, the value is not popped from the stack.
 
 
                                     --
 
.context StgW1
.context StgW2
.context StgW3
.context StgW4
.context StgW5
.context StgW6
.context StgW7
.context StgWb
.context StgLb
.context StgR
.context StgD
.context StgT
.context StgW0
.context @L805c
:z3
                                              \aUp\vadvisor.hlp!h.contents\v \aContents\vadvisor.hlp!h.contents\v \aIndex\vadvisor.hlp!h.index\v \aBack\v!B\v
컴P-Code Instructions컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 
:nStg<t><n>
  Syntax
 
  Stg<t><n>
 
  /* Store value to global address */
 
  Possible Instructions
 
  StgW0...StgW7, StgWb, StgLb, StgR, StgD, StgT
 
  See: \aP-Code Data Types\v@L8070\v
       \aP-Code Operands\v@L8071\v
 
  Description
 
  Transfers the value on top of the stack to the specified global variable
  and pops it off the stack. The address of the global variable is found
  relative to the current procedure (for Stg<t>#) or the program segment
  (for Stg<t>b).
 
  Pseudocode equivalent:
 
  **(prgSeg + <n>) = Pop<t>();     or
  **(prgProc + <n>) = Pop<t>();
 
  If the index <n> is specified as an immediate operand, then the global
  variable address can be either near or far. The decision is made by the
  compiler, and implemented at run time using a range check on the index.
 
  Assigning a value to a global variable generates this instruction:
 
  fGlobal = 10;       /* generates StgW<n> */
 
 
                                     --
 
.context StifWb
.context StifLb
.context StifD
.context StifR
.context StifT
.context StifBb
.context @L805d
:z3
                                              \aUp\vadvisor.hlp!h.contents\v \aContents\vadvisor.hlp!h.contents\v \aIndex\vadvisor.hlp!h.index\v \aBack\v!B\v
컴P-Code Instructions컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 
:nStif<t><n>
  Syntax
 
  Stif<t><n>
 
  /* Store value indirect through far pointer */
 
  Possible Instructions
 
  StifBb, StifWb, StifLb, StifD, StifR, StifT
 
  See: \aP-Code Data Types\v@L8070\v
       \aP-Code Operands\v@L8071\v
 
  Description
 
  Stores an indirect word value. The top-of-stack element is assumed to be
  a long pointer and is taken off of the stack.
 
  Pseudocode equivalent:
 
  lpw = (int far *)LongPop() + S;
  *lpw = Pop();
 
  This instruction is generated as follows:
 
  w = 5;
  *lpw = w;           /* generates StifWb */
 
 
                                     --
 
.context StifoW
.context StifoL
.context StifoB
.context @L805e
:z3
                                              \aUp\vadvisor.hlp!h.contents\v \aContents\vadvisor.hlp!h.contents\v \aIndex\vadvisor.hlp!h.index\v \aBack\v!B\v
컴P-Code Instructions컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 
:nStifo<t>
  Syntax
 
  Stifo<t>
 
  /* Store value indirect through far pointer + offset. */
 
  Possible Instructions
 
  StifoB, StifoW, StifoL
 
  See: \aP-Code Data Types\v@L8070\v
 
  Description
 
  Generally used to optimize stores to char, int, and long arrays. It
  stores indirect a value using a far pointer and a scaled offset on the
  stack.
 
  Pseudocode equivalent:
 
  lp<t> = (<t> far *)PopL() + PopW() * sizeof(<t>);
  *lp<t> = Pop<t>();
 
  lpw[i] = 10;             /* generates StifoW */
 
 
                                     --
 
.context StifQW
.context @L805f
:z3
                                              \aUp\vadvisor.hlp!h.contents\v \aContents\vadvisor.hlp!h.contents\v \aIndex\vadvisor.hlp!h.index\v \aBack\v!B\v
컴P-Code Instructions컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 
:nStifQW<b>
  Syntax
 
  StifQW<b>
 
  /* Store indirect bit field into word using far pointer. */
 
  Description
 
  Pops the far pointer and a word from the top of the stack and merges the
  bit field contained within the word with the contents of the word stored
  at the location referenced by the far pointer.
 
  The one byte parameter <b> specifies the shift count (0-15) and the
  width (minus 1) of the bit field (0-15).
 
  Pseudocode equivalent:
 
  int far *lpw;
  unsigned int w, width, shift, mask;
  lpw = PopL();
  w = PopW();
  width = (<b> >> 4) + 1;
  shift = (<b> & 0xf0);
  mask = ~((~(0xffff << width)) << shift);
  *lpw = (*lpw & mask) | ((w << shift) & mask);
 
 
                                     --
 
.context StiftW
.context StiftB
.context @L8060
:z3
                                              \aUp\vadvisor.hlp!h.contents\v \aContents\vadvisor.hlp!h.contents\v \aIndex\vadvisor.hlp!h.index\v \aBack\v!B\v
컴P-Code Instructions컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 
:nStift<t>
  Syntax
 
  Stift<t>
 
  /* Store item indirect using far pointer in t register. */
 
  Possible Instructions
 
  StiftB, StiftW
 
  See: \aP-Code Data Types\v@L8070\v
       \aP-Code Operands\v@L8071\v
 
  Description
 
  Using the long value in the p-code temporary register t as a far
  pointer, stores the top item on the stack in the location pointed to by
  t.
 
  Pseudocode equivalent:
 
  lp<t> = t;
  *lp<t> = Pop<t>();
 
 
                                     --
 
.context StinBb
.context StinW0
.context StinW1
.context StinW2
.context StinWb
.context StinL0
.context StinLb
.context StinD
.context StinR
.context StinT
.context StinB0
.context @L8061
:z3
                                              \aUp\vadvisor.hlp!h.contents\v \aContents\vadvisor.hlp!h.contents\v \aIndex\vadvisor.hlp!h.index\v \aBack\v!B\v
컴P-Code Instructions컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 
:nStin<t><n>
  Syntax
 
  Stin<t><n>
 
  /* Store item indirect using near pointer. */
 
  Possible Instructions
 
  StinB0, StinBb, StinW0, StinW1, StinW2, StinWb, StinL0, StinLb, StinD,
  StinR, StinT
 
  See: \aP-Code Data Types\v@L8070\v
       \aP-Code Operands\v@L8071\v
 
  Description
 
  Pops an address and then a value of type <t> from the stack. It then
  stores the value in the location pointed to by the address.
 
  Pseudocode equivalent:
 
  p<t> = PopW() + alignof(<t>) * <n>;
  *p<t> = Pop<t>();
 
  An example where this instruction is used is as follows:
 
  *pShort = rgshort[1]++;  /* generates StinW<n> */
 
 
                                     --
 
.context StinQW
.context @L8062
:z3
                                              \aUp\vadvisor.hlp!h.contents\v \aContents\vadvisor.hlp!h.contents\v \aIndex\vadvisor.hlp!h.index\v \aBack\v!B\v
컴P-Code Instructions컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 
:nStinQW<b>
  Syntax
 
  StinQW<b>
 
  /* Store indirect bit field into word using near pointer. */
 
  Description
 
  Pops the near pointer and a word from the top of the stack and merges
  the bit field contained within the word with the contents of the word
  stored at the location referenced by the near pointer.
 
  The one byte parameter <b> specifies the shift count (0-15) and the
  width (minus 1) of the bit field (0-15).
 
 
                                     --
 
.context StinoW
.context StinoL
.context StinoB
.context @L8063
:z3
                                              \aUp\vadvisor.hlp!h.contents\v \aContents\vadvisor.hlp!h.contents\v \aIndex\vadvisor.hlp!h.index\v \aBack\v!B\v
컴P-Code Instructions컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 
:nStino<t>
  Syntax
 
  Stino<t>
 
  /* Store value indirect through near pointer + offset. */
 
  Possible Instructions
 
  StinoB, StinoW, StinoL
 
  See: \aP-Code Data Types\v@L8070\v
       \aP-Code Operands\v@L8071\v
 
  Description
 
  Generally used to optimize stores to char, int, and long arrays. It
  stores indirect a value using a near pointer and a scaled offset on the
  stack.
 
  Pseudocode equivalent:
 
  p<t> = (<t> *)PopW() + PopW() * sizeof(<t>);
  *p<t> = Pop<t>();
 
  pw[i] = 10;              /* generates StinoW */
 
 
                                     --
 
.context StinpB0
.context @L8064
:z3
                                              \aUp\vadvisor.hlp!h.contents\v \aContents\vadvisor.hlp!h.contents\v \aIndex\vadvisor.hlp!h.index\v \aBack\v!B\v
컴P-Code Instructions컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 
:nStinp<t><n>
  Syntax
 
  Stinp<t><n>
 
  /* Store indirect near and preserve item. */
 
  Possible Instructions
 
  StinpB0
 
  See: \aP-Code Data Types\v@L8070\v
       \aP-Code Operands\v@L8071\v
 
  Description
 
  Stores an indirect near the top value on the stack without popping the
  value. This instruction is used to store through a pointer in situations
  where the value has to be left on the stack.
 
  Pseudocode equivalent:
 
  p<t> = PopW() + alignof(<t>) * n;
  *p<t> = Top<t>();
 
 
                                     --
 
.context StintW
.context StintB
.context @L8065
:z3
                                              \aUp\vadvisor.hlp!h.contents\v \aContents\vadvisor.hlp!h.contents\v \aIndex\vadvisor.hlp!h.index\v \aBack\v!B\v
컴P-Code Instructions컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 
:nStint<t>
  Syntax
 
  Stint<t>
 
  /* Store item indirect using t register */
 
  Possible Instructions
 
  StintB, StintW
 
  Description
 
  Stores an indirect word pointer in the p-code temporary register t.
 
  Pseudocode equivalent:
 
  *t = Pop<t>();
 
  Decrementing a word pointer generates this instruction:
 
  rgw[2] = --rgw[1];       /* generates StintW */
 
 
                                     --
 
.context StixWb
.context @L8066
:z3
                                              \aUp\vadvisor.hlp!h.contents\v \aContents\vadvisor.hlp!h.contents\v \aIndex\vadvisor.hlp!h.index\v \aBack\v!B\v
컴P-Code Instructions컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 
:nStixWb
  Syntax
 
  StixWb
 
  /* Store the word to *(this + offset) */
 
  Description
 
  Stores the word in the location pointed to by *(this + offset).
 
  See \aLdixWb\v@L803f\v for more details.
 
 
                                     --
 
.context StixLb
.context @L8067
:z3
                                              \aUp\vadvisor.hlp!h.contents\v \aContents\vadvisor.hlp!h.contents\v \aIndex\vadvisor.hlp!h.index\v \aBack\v!B\v
컴P-Code Instructions컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 
:nStixLb
  Syntax
 
  StixLb
 
  /* Store the long to *(this + offset) */
 
  Description
 
  Stores the long in the location pointed to by *(this + offset).
 
  See \aLdixWb\v@L803f\v for more details.
 
 
                                     --
 
.context SttW
.context @L8068
:z3
                                              \aUp\vadvisor.hlp!h.contents\v \aContents\vadvisor.hlp!h.contents\v \aIndex\vadvisor.hlp!h.index\v \aBack\v!B\v
컴P-Code Instructions컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 
:nSttW
  Syntax
 
  SttW
 
  /* Store top of stack in t register. */
 
  Description
 
  Stores the value at the top of the stack into the p-code temporary
  register t.
 
  Pseudocode equivalent:
 
  t = Pop();
 
  Doing a right shift to a long variable type generates this instruction.
  Temporary results are stored and then loaded back onto the stack to
  complete the shift:
 
  lTest1 = lTest2 >> 1     /* generates SttW */
 
 
                                     --
 
.context SubL
.context SubT
.context SubW
.context @L8069
:z3
                                              \aUp\vadvisor.hlp!h.contents\v \aContents\vadvisor.hlp!h.contents\v \aIndex\vadvisor.hlp!h.index\v \aBack\v!B\v
컴P-Code Instructions컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 
:nSub<t>
  Syntax
 
  Sub<t>
 
  /* Subtract top two items on stack */
 
  Possible Instructions
 
  SubW, SubL, SubT
 
  See: \aP-Code Data Types\v@L8070\v
       \aP-Code Operands\v@L8071\v
 
  Description
 
  Pops the top two elements off the stack, subtracts the second from the
  first, and pushes the result back onto the stack.
 
  Pseudocode equivalent:
 
  <t>1 = Pop<t>();
  <t>2 = Pop<t>();
  Push<t>(<t>1 - <t>2);
 
 
                                     --
 
.context SwapW
.context @L806a
:z3
                                              \aUp\vadvisor.hlp!h.contents\v \aContents\vadvisor.hlp!h.contents\v \aIndex\vadvisor.hlp!h.index\v \aBack\v!B\v
컴P-Code Instructions컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 
:nSwapW
  Syntax
 
  SwapW
 
  /* Swap the top two words on the on the stack. */
 
  Description
 
  Swaps the two top words on the stack by popping them off of the stack
  and then pushing them back on in opposite order.
 
  Pseudocode equivalent:
 
  unsigned w2, w1;
  w2 = Pop();
  w1 = Pop();
  Push(w2);
  Push(w1);
 
  This is generated in the following example:
 
  *lp = 100000l;
  wT = (int)*lp;           /* generates SwapW */
 
 
                                     --
 
.context SwapT
.context @L806b
:z3
                                              \aUp\vadvisor.hlp!h.contents\v \aContents\vadvisor.hlp!h.contents\v \aIndex\vadvisor.hlp!h.index\v \aBack\v!B\v
컴P-Code Instructions컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 
:nSwapT
  Syntax
 
  SwapT
 
  /* Swap the top two floating point values on the floating point stack.
  */
 
  Description
 
  Swaps the two top temporary real values on the floating point stack by
  popping them off of the stack and then pushing them back on in the
  opposite order.
 
  Pseudocode equivalent:
 
  treal t2, t1;
  t2 = FpPop();
  t1 = FpPop();
  FpPush(t2);
  FpPush(t1);
 
 
                                     --
 
.context UnSpillTb
.context @L806c
:z3
                                              \aUp\vadvisor.hlp!h.contents\v \aContents\vadvisor.hlp!h.contents\v \aIndex\vadvisor.hlp!h.index\v \aBack\v!B\v
컴P-Code Instructions컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 
:nUnSpillTb
  Syntax
 
  UnSpillTb
 
  /* UnSpill floating point stack. */
 
  Description
 
  Reverses the operation of the SpillTb instruction by rereading the
  previous contents of the floating-point stack from memory.
 
 
                                     --
 
.context XorL
.context XorW
.context @L806d
:z3
                                              \aUp\vadvisor.hlp!h.contents\v \aContents\vadvisor.hlp!h.contents\v \aIndex\vadvisor.hlp!h.index\v \aBack\v!B\v
컴P-Code Instructions컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 
:nXor<t>
  Syntax
 
  Xor<t>
 
  /* Bitwise logical 'xor' top two words on stack */
 
  Possible Instructions
 
  XorW, XorL
 
  See: \aP-Code Data Types\v@L8070\v
       \aP-Code Operands\v@L8071\v
 
  Description
 
  Pops two elements from the stack and performs a logical exclusive 'or'
  on them. It then pushes the result back onto the stack.
 
  Pseudocode equivalent:
 
  w2 = Pop();
  w1 = Pop();
  Push(w1 ^ w2);
 
  This can be generated by the following:
 
  if ((w1 ^ w2) != 25)     /* generates XorW */
 
 
                                     --
 
.context pcode.contents
.context pcode
.context pcode.contents
.context @L806e
:nP-Code
:z3
                                              \aUp\vadvisor.hlp!h.contents\v \aContents\vadvisor.hlp!h.contents\v \aIndex\vadvisor.hlp!h.index\v \aBack\v!B\v
컴P-Code Instructions컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 
     \aP-Code Instruction Syntax\v@L806f\v
     \aP-Code Data Types\v@L8070\v
     \aP-Code Operands\v@L8071\v
     \aMake P-Code Utility (MPC)\v@L8072\v
 
     \aAlphabetical Index of P-Code Instructions\vpcode.index\v
 
 
                                     --
 
.context pcode.syntax
.context P-Code Instruction Syntax
.context @L806f
:nP-Code Instruction Syntax
:z3
                                              \aUp\vadvisor.hlp!h.contents\v \aContents\vadvisor.hlp!h.contents\v \aIndex\vadvisor.hlp!h.index\v \aBack\v!B\v
컴P-Code Instructions컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 
  Syntax
 
  <op> [<indir_mode>] [<quals>] [<data_type>] [<operand>] [<retval>]
 
  Parameter    Description
 
  <op>         The basic opcode. For example, Ldf, Ldi, Sti, Ldng, or
               Stfg.
 
  <indir mode> The indirection mode.
 
               Value   Meaning
               n       Near
               f       Far
               h       Huge (as defined in Microsoft C)
               no      Near + offset
               fo      Far + offset
               ho      Huge + offset
 
  <quals>      The qualifiers, zero or more of
 
               Value   Meaning
               p       Preserve data on stack after instruction
               t       Fetch operand from temp register
               s       Signed or scaled
               u       Unsigned
 
  <data_type>  The data type, zero or more of
 
               Value   Meaning
               V       Void
               B       Byte
               Q       Bit field
               W       Word
               S       Short (word 컴 reserved for 386 version)
               L       Long (double word)
               N       Pointer (near)
               A       Address (near)
               F       Pointer (far)
               H       Pointer (huge)
               R       Float (4 bytes)
               D       Double (8 bytes)
               T       Long double (10 bytes)
 
               When more than one <data_type> is specified, they appear in
               the following order:
 
                  Left operand (below top of stack)
 
                  Right operand (at top of stack)
 
                  Result of the operation
 
  <operand>    The operand, zero or more of
 
               Value   Meaning
               #       Implied numeric operand, encoded in the opcode ("#"
                       denotes a sequence of decimal digits)
               m#      Minus컴implied negative numeric operand
               b       Byte (1 byte operand)
               w       Word (2 byte operand)
               l       Long  (4 byte operand)
 
  <retval>     The return value. This parameter is used for procedure
               calls only.
 
               Value   Meaning
               .V      Void return value
               .W      2-byte return value
               .L      4-byte return value
 
 
                                     --
 
.context pcode.datatypes
.context P-Code Data Types
.context @L8070
:nP-Code Data Types
:z3
                                              \aUp\vadvisor.hlp!h.contents\v \aContents\vadvisor.hlp!h.contents\v \aIndex\vadvisor.hlp!h.index\v \aBack\v!B\v
컴P-Code Instructions컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 
  The data type <t> is zero or more of
 
  Value   Meaning
  V       Void
  B       Byte
  Q       Bit field
  W       Word
  S       Short (word 컴 reserved for 386 version)
  L       Long (double word)
  N       Pointer (near)
  A       Address (near)
  F       Pointer (far)
  H       Pointer (huge)
  R       Float (4 bytes)
  D       Double (8 bytes)
  T       Long double (10 bytes)
 
  See: \aP-Code Syntax\v@L806f\v
 
  When more than one <data_type> is specified, they appear in the
  following order:
 
     Left operand (below top of stack)
 
     Right operand (at top of stack)
 
     Result of the operation
 
 
                                     --
 
.context pcode.operands
.context P-Code Operands
.context @L8071
:nP-Code Operands
:z3
                                              \aUp\vadvisor.hlp!h.contents\v \aContents\vadvisor.hlp!h.contents\v \aIndex\vadvisor.hlp!h.index\v \aBack\v!B\v
컴P-Code Instructions컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 
  The operand <n> is zero or more of the following:
 
  Value   Meaning
  #       Implied numeric operand, encoded in the opcode ("#" denotes a
          sequence of decimal digits)
  m#      Minus컴implied negative numeric operand
  b       Byte (1 byte operand)
  w       Word (2 byte operand)
  l       Long  (4 byte operand)
 
  See: \aP-Code Syntax\v@L806f\v
 
                                     --
 
.context MPC.EXE
.context MPC
.context @L8072
:nMPC
:z3
                                              \aUp\vadvisor.hlp!h.contents\v \aContents\vadvisor.hlp!h.contents\v \aIndex\vadvisor.hlp!h.index\v \aBack\v!B\v
컴P-Code Instructions컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 
  Syntax
 
  MPC [/Fe outputfile] [inputfile]
 
  Controlling the P-Code Build Process
 
  When you compile a program into machine code from the command line, CL
  performs the compilation and then calls LINK to do the linking. When you
  use the /Oq option to compile a program into p-code, CL calls one other
  program in addition to LINK: the Make P-Code utility (MPC).
 
  CL calls the MPC utility after calling LINK. MPC reads the executable
  (.EXE) file produced by LINK and generates several internal tables
  needed by the run-time interpreter. Once MPC has added these tables, the
  executable file is ready to run.
 
  MPC requires a segmented executable file as input, even if DOS is the
  target. P-code object modules contain special-purpose records that force
  the generation of a segmented executable.
 
  If you want to separate the compilation phase from the link and
  post-link phases, specify the /c option in addition to the /Oq option.
  This option tells CL to stop after the compilation step. You can run
  LINK and MPC in one step by specifying the /PCODE option for LINK. For
  example, the command
 
  LINK /PCODE MYPROG.OBJ
 
  links MYPROG.OBJ and runs MPC on the resulting executable MYPROG.EXE.
 
  You can also invoke invoke MPC individually. If you don't specify the
  /PCODE option, LINK performs only the standard linking procedure and
  does not call any additional programs. However, if the .OBJ file
  contains p-code, LINK cannot produce a file that can be executed. MPC is
  required to make a p-code program executable.
 
  Use the MPC program to convert the LINK output into an .EXE file that
  you can run. Specify a name for MPC's output file using the /Fe option.
  For example:
 
  MPC /Fe MYPROG.EXE MYPROG.PXE
 
  This command reads MYPROG.PXE (linker output) and produces a file named
  MYPROG.EXE. If you don't specify the /Fe option, MPC uses the name of
  the input file.
 
                                     --
.context h.pg1
.context @L8073
:z7
:nP-Code Instructions Index [1]
:l12
                                             \aUp\vadvisor.hlp!vx\v \aContents\vadvisor.hlp!hv\v \aIndex\vadvisor.hlp!vx\v \aBack\v!B\v
컴P-Code Instructions Index컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 
  旼쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡
  \aA\v@L8074\v\aB\v@L8075\v\aC\v@L8076\v\aD\v@L8077\v\aE\v@L8078\v\aF\v@L8079\v\aG\v@L807a\v\aH\v@L807b\v\aI\v@L807c\v\aJ\v@L807d\v\aK\v@L807e\v\aL\v@L807f\v\aM\v@L8080\v\aN\v@L8081\v\aO\v@L8082\v\aP\v@L8083\v\aQ\v@L8084\v\aR\v@L8085\v\aS\v@L8086\v\aT\v@L8087\v\aU\v@L8088\v\aV\v@L8089\v\aW\v@L808a\v\aX-Z\v@L808b\v*
  읕좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔
 
   No entries.
                                    --
.context pcode.index
.context @L8074
:z7
:nP-Code Instructions Index [2]
:l14
                                             \aUp\vadvisor.hlp!vx\v \aContents\vadvisor.hlp!hv\v \aIndex\vadvisor.hlp!vx\v \aBack\v!B\v
컴P-Code Instructions Index컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 
  旼쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡
  쿌\aB\v@L8075\v\aC\v@L8076\v\aD\v@L8077\v\aE\v@L8078\v\aF\v@L8079\v\aG\v@L807a\v\aH\v@L807b\v\aI\v@L807c\v\aJ\v@L807d\v\aK\v@L807e\v\aL\v@L807f\v\aM\v@L8080\v\aN\v@L8081\v\aO\v@L8082\v\aP\v@L8083\v\aQ\v@L8084\v\aR\v@L8085\v\aS\v@L8086\v\aT\v@L8087\v\aU\v@L8088\v\aV\v@L8089\v\aW\v@L808a\v\aX-Z\v@L808b\v\a*\v@L8073\v
  읕좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔
 
   \aAdd<t>             Add top two items on stack\v@L8000\v
   \aAddWP              Add scaled integer word to pointer\v@L8001\v
   \aAnd<t>             Bitwise logical 'and' top two items on stack\v@L8002\v
                                    --
.context @L8075
:z7
:nP-Code Instructions Index [3]
:l13
                                             \aUp\vadvisor.hlp!vx\v \aContents\vadvisor.hlp!hv\v \aIndex\vadvisor.hlp!vx\v \aBack\v!B\v
컴P-Code Instructions Index컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 
  旼쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡
  \aA\v@L8074\v쿍\aC\v@L8076\v\aD\v@L8077\v\aE\v@L8078\v\aF\v@L8079\v\aG\v@L807a\v\aH\v@L807b\v\aI\v@L807c\v\aJ\v@L807d\v\aK\v@L807e\v\aL\v@L807f\v\aM\v@L8080\v\aN\v@L8081\v\aO\v@L8082\v\aP\v@L8083\v\aQ\v@L8084\v\aR\v@L8085\v\aS\v@L8086\v\aT\v@L8087\v\aU\v@L8088\v\aV\v@L8089\v\aW\v@L808a\v\aX-Z\v@L808b\v\a*\v@L8073\v
  읕좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔
 
   \aBltFFB             Block copy using far pointers\v@L8003\v
   \aBltFFBF            Block copy, use and return far pointers\v@L8004\v
                                    --
.context @L8076
:z7
:nP-Code Instructions Index [4]
:l36
                                             \aUp\vadvisor.hlp!vx\v \aContents\vadvisor.hlp!hv\v \aIndex\vadvisor.hlp!vx\v \aBack\v!B\v
컴P-Code Instructions Index컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 
  旼쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡
  \aA\v@L8074\v\aB\v@L8075\v쿎\aD\v@L8077\v\aE\v@L8078\v\aF\v@L8079\v\aG\v@L807a\v\aH\v@L807b\v\aI\v@L807c\v\aJ\v@L807d\v\aK\v@L807e\v\aL\v@L807f\v\aM\v@L8080\v\aN\v@L8081\v\aO\v@L8082\v\aP\v@L8083\v\aQ\v@L8084\v\aR\v@L8085\v\aS\v@L8086\v\aT\v@L8087\v\aU\v@L8088\v\aV\v@L8089\v\aW\v@L808a\v\aX-Z\v@L808b\v\a*\v@L8073\v
  읕좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔
 
   \aCallD#             Direct p-code call; pop parameters and push return\v@L8005\v
   \aCallDb             Direct p-code call; pop parameters and push return\v@L8006\v
   \aCallDbb            Direct p-code call; pop parameters and push return\v@L8007\v
   \aCallDbw            Direct p-code call; pop parameters and push return\v@L8008\v
   \aCallS#             Direct p-code call; pop parameters and push return\v@L8009\v
   \aCallSb             Direct p-code call; pop parameters and push return\v@L800a\v
   \aCallSbb            Direct p-code call; pop parameters and push return\v@L800b\v
   \aCallSbw            Direct p-code call; pop parameters and push return\v@L800c\v
   \aCallifc<t>         Indirect call to __far __cdecl function\v@L800d\v
   \aCallifp<t>         Indirect call to __far __pascal function\v@L800e\v
   \aCallinc<t>         Indirect call to __near __cdecl function\v@L800f\v
   \aCallinp<t>         Indirect call to __near __pascal function\v@L8010\v
   \aCallxbb            Call a virtual function\v@L8011\v
   \aCallybb            Multiple-inheritance call to virtual function\v@L8012\v
   \aCase<t>            Perform Switch/Case operation\v@L8013\v
   \aChkstk             Check for Stack Overflow\v@L8014\v
   \aClrfB<n>           Clear Frame Byte\v@L8015\v
   \aCmpsL              Compare top two signed longs on stack\v@L8016\v
   \aCmpT               Compare top two floating point values\v@L8017\v
   \aCmpu<t>            Compare top two items on stack as unsigned values\v@L8018\v
   \aCvtBW              Convert byte to word (sign extended)\v@L8019\v
   \aCvt<t>T            Convert integer to temp-real\v@L801a\v
   \aCvtWL              Convert word to long\v@L801b\v
   \aCvtWuQ<n>          Convert word to unsigned bit field\v@L801c\v
   \aCvtWQ<n>           Convert word to signed bit field\v@L801d\v
                                    --
.context @L8077
:z7
:nP-Code Instructions Index [5]
:l15
                                             \aUp\vadvisor.hlp!vx\v \aContents\vadvisor.hlp!hv\v \aIndex\vadvisor.hlp!vx\v \aBack\v!B\v
컴P-Code Instructions Index컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 
  旼쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡
  \aA\v@L8074\v\aB\v@L8075\v\aC\v@L8076\v쿏\aE\v@L8078\v\aF\v@L8079\v\aG\v@L807a\v\aH\v@L807b\v\aI\v@L807c\v\aJ\v@L807d\v\aK\v@L807e\v\aL\v@L807f\v\aM\v@L8080\v\aN\v@L8081\v\aO\v@L8082\v\aP\v@L8083\v\aQ\v@L8084\v\aR\v@L8085\v\aS\v@L8086\v\aT\v@L8087\v\aU\v@L8088\v\aV\v@L8089\v\aW\v@L808a\v\aX-Z\v@L808b\v\a*\v@L8073\v
  읕좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔
 
   \aDecW<n>            Decrement top word on stack\v@L801e\v
   \aDiv<t>             Divide top two items on stack\v@L801f\v
   \aDivLWW             Divide long by word, push word result\v@L8020\v
   \aDrop<t>            Drop (pop and discard) top item on stack\v@L8021\v
                                    --
.context @L8078
:z7
:nP-Code Instructions Index [6]
:l13
                                             \aUp\vadvisor.hlp!vx\v \aContents\vadvisor.hlp!hv\v \aIndex\vadvisor.hlp!vx\v \aBack\v!B\v
컴P-Code Instructions Index컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 
  旼쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡
  \aA\v@L8074\v\aB\v@L8075\v\aC\v@L8076\v\aD\v@L8077\v쿐\aF\v@L8079\v\aG\v@L807a\v\aH\v@L807b\v\aI\v@L807c\v\aJ\v@L807d\v\aK\v@L807e\v\aL\v@L807f\v\aM\v@L8080\v\aN\v@L8081\v\aO\v@L8082\v\aP\v@L8083\v\aQ\v@L8084\v\aR\v@L8085\v\aS\v@L8086\v\aT\v@L8087\v\aU\v@L8088\v\aV\v@L8089\v\aW\v@L808a\v\aX-Z\v@L808b\v\a*\v@L8073\v
  읕좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔
 
   \aEquote             Mark end of quoted region\v@L8022\v
   \aExo                Extended opcode prefix\v@L8023\v
                                    --
.context @L8079
:z7
:nP-Code Instructions Index [7]
:l12
                                             \aUp\vadvisor.hlp!vx\v \aContents\vadvisor.hlp!hv\v \aIndex\vadvisor.hlp!vx\v \aBack\v!B\v
컴P-Code Instructions Index컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 
  旼쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡
  \aA\v@L8074\v\aB\v@L8075\v\aC\v@L8076\v\aD\v@L8077\v\aE\v@L8078\v쿑\aG\v@L807a\v\aH\v@L807b\v\aI\v@L807c\v\aJ\v@L807d\v\aK\v@L807e\v\aL\v@L807f\v\aM\v@L8080\v\aN\v@L8081\v\aO\v@L8082\v\aP\v@L8083\v\aQ\v@L8084\v\aR\v@L8085\v\aS\v@L8086\v\aT\v@L8087\v\aU\v@L8088\v\aV\v@L8089\v\aW\v@L808a\v\aX-Z\v@L808b\v\a*\v@L8073\v
  읕좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔
 
   No entries.
                                    --
.context @L807a
:z7
:nP-Code Instructions Index [8]
:l13
                                             \aUp\vadvisor.hlp!vx\v \aContents\vadvisor.hlp!hv\v \aIndex\vadvisor.hlp!vx\v \aBack\v!B\v
컴P-Code Instructions Index컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 
  旼쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡
  \aA\v@L8074\v\aB\v@L8075\v\aC\v@L8076\v\aD\v@L8077\v\aE\v@L8078\v\aF\v@L8079\v쿒\aH\v@L807b\v\aI\v@L807c\v\aJ\v@L807d\v\aK\v@L807e\v\aL\v@L807f\v\aM\v@L8080\v\aN\v@L8081\v\aO\v@L8082\v\aP\v@L8083\v\aQ\v@L8084\v\aR\v@L8085\v\aS\v@L8086\v\aT\v@L8087\v\aU\v@L8088\v\aV\v@L8089\v\aW\v@L808a\v\aX-Z\v@L808b\v\a*\v@L8073\v
  읕좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔
 
   \aGoto<n>            Goto offset\v@L8024\v
   \aGoton<n>           Short jump backwards\v@L8025\v
                                    --
.context @L807b
:z7
:nP-Code Instructions Index [9]
:l12
                                             \aUp\vadvisor.hlp!vx\v \aContents\vadvisor.hlp!hv\v \aIndex\vadvisor.hlp!vx\v \aBack\v!B\v
컴P-Code Instructions Index컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 
  旼쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡
  \aA\v@L8074\v\aB\v@L8075\v\aC\v@L8076\v\aD\v@L8077\v\aE\v@L8078\v\aF\v@L8079\v\aG\v@L807a\v쿓\aI\v@L807c\v\aJ\v@L807d\v\aK\v@L807e\v\aL\v@L807f\v\aM\v@L8080\v\aN\v@L8081\v\aO\v@L8082\v\aP\v@L8083\v\aQ\v@L8084\v\aR\v@L8085\v\aS\v@L8086\v\aT\v@L8087\v\aU\v@L8088\v\aV\v@L8089\v\aW\v@L808a\v\aX-Z\v@L808b\v\a*\v@L8073\v
  읕좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔
 
   No entries.
                                    --
.context @L807c
:z7
:nP-Code Instructions Index [10]
:l16
                                             \aUp\vadvisor.hlp!vx\v \aContents\vadvisor.hlp!hv\v \aIndex\vadvisor.hlp!vx\v \aBack\v!B\v
컴P-Code Instructions Index컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 
  旼쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡
  \aA\v@L8074\v\aB\v@L8075\v\aC\v@L8076\v\aD\v@L8077\v\aE\v@L8078\v\aF\v@L8079\v\aG\v@L807a\v\aH\v@L807b\v쿔\aJ\v@L807d\v\aK\v@L807e\v\aL\v@L807f\v\aM\v@L8080\v\aN\v@L8081\v\aO\v@L8082\v\aP\v@L8083\v\aQ\v@L8084\v\aR\v@L8085\v\aS\v@L8086\v\aT\v@L8087\v\aU\v@L8088\v\aV\v@L8089\v\aW\v@L808a\v\aX-Z\v@L808b\v\a*\v@L8073\v
  읕좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔
 
   \aInc<t><n>          Increment top element on stack\v@L8026\v
   \aIncf<t><n>         Increment frame variable by 1\v@L8027\v
   \aIncf<t><n><m>      Increment frame variable by specified value\v@L8028\v
   \aIncg<t><n><m>      Increment global variable by specified value\v@L8029\v
   \aInt3               Software interrupt for the p-code machine\v@L802a\v
                                    --
.context @L807d
:z7
:nP-Code Instructions Index [11]
:l19
                                             \aUp\vadvisor.hlp!vx\v \aContents\vadvisor.hlp!hv\v \aIndex\vadvisor.hlp!vx\v \aBack\v!B\v
컴P-Code Instructions Index컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 
  旼쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡
  \aA\v@L8074\v\aB\v@L8075\v\aC\v@L8076\v\aD\v@L8077\v\aE\v@L8078\v\aF\v@L8079\v\aG\v@L807a\v\aH\v@L807b\v\aI\v@L807c\v쿕\aK\v@L807e\v\aL\v@L807f\v\aM\v@L8080\v\aN\v@L8081\v\aO\v@L8082\v\aP\v@L8083\v\aQ\v@L8084\v\aR\v@L8085\v\aS\v@L8086\v\aT\v@L8087\v\aU\v@L8088\v\aV\v@L8089\v\aW\v@L808a\v\aX-Z\v@L808b\v\a*\v@L8073\v
  읕좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔
 
   \aJeqW<n>            Branch on Equal\v@L802b\v
   \aJgeW<n>            Branch on Greater or Equal\v@L802c\v
   \aJgtW<n>            Branch on Greater Than\v@L802d\v
   \aJleW<n>            Branch on Less than or Equal\v@L802e\v
   \aJltW<n>            Branch on Less Than\v@L802f\v
   \aJneW<n>            Branch on Not Equal\v@L8030\v
   \aJnzW<n>            Branch on Not Zero\v@L8031\v
   \aJzrW<n>            Branch on Zero\v@L8032\v
                                    --
.context @L807e
:z7
:nP-Code Instructions Index [12]
:l12
                                             \aUp\vadvisor.hlp!vx\v \aContents\vadvisor.hlp!hv\v \aIndex\vadvisor.hlp!vx\v \aBack\v!B\v
컴P-Code Instructions Index컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 
  旼쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡
  \aA\v@L8074\v\aB\v@L8075\v\aC\v@L8076\v\aD\v@L8077\v\aE\v@L8078\v\aF\v@L8079\v\aG\v@L807a\v\aH\v@L807b\v\aI\v@L807c\v\aJ\v@L807d\v쿖\aL\v@L807f\v\aM\v@L8080\v\aN\v@L8081\v\aO\v@L8082\v\aP\v@L8083\v\aQ\v@L8084\v\aR\v@L8085\v\aS\v@L8086\v\aT\v@L8087\v\aU\v@L8088\v\aV\v@L8089\v\aW\v@L808a\v\aX-Z\v@L808b\v\a*\v@L8073\v
  읕좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔
 
   No entries.
                                    --
.context @L807f
:z7
:nP-Code Instructions Index [13]
:l27
                                             \aUp\vadvisor.hlp!vx\v \aContents\vadvisor.hlp!hv\v \aIndex\vadvisor.hlp!vx\v \aBack\v!B\v
컴P-Code Instructions Index컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 
  旼쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡
  \aA\v@L8074\v\aB\v@L8075\v\aC\v@L8076\v\aD\v@L8077\v\aE\v@L8078\v\aF\v@L8079\v\aG\v@L807a\v\aH\v@L807b\v\aI\v@L807c\v\aJ\v@L807d\v\aK\v@L807e\v쿗\aM\v@L8080\v\aN\v@L8081\v\aO\v@L8082\v\aP\v@L8083\v\aQ\v@L8084\v\aR\v@L8085\v\aS\v@L8086\v\aT\v@L8087\v\aU\v@L8088\v\aV\v@L8089\v\aW\v@L808a\v\aX-Z\v@L808b\v\a*\v@L8073\v
  읕좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔
 
   \aLdc<t><n>          Push a constant on stack.\v@L8033\v
   \aLdfA<n>            Load Address of Frame Variable\vLdfA0\v
   \aLdf<t><n>          Load frame relative item\v@L8035\v
   \aLdgA<n>            Push address of the global variable onto the stack\v@L8036\v
   \aLdg<t><n>          Push global variable on stack\v@L8037\v
   \aLdif<t><n>         Load indirect from far pointer\v@L8038\v
   \aLdifo<t>           Load indrect far item with scaled offset\v@L8039\v
   \aLdift<t>           Load item indirect far through t register\v@L803a\v
   \aLdiho<t>           Load indrect huge item with scaled offset\v@L803b\v
   \aLdin<t><n>         Load indirect using near pointer\v@L803c\v
   \aLdino<t>           Load indrect item with scaled offset\v@L803d\v
   \aLdint<t>           Load item indirect near through t register\v@L803e\v
   \aLdixWb             Push the word at *(this + offset)\v@L803f\v
   \aLdixLb             Push the long at *(this + offset)\v@L8040\v
   \aLdp<t><n>          Load parameter\v@L8041\v
   \aLdt<t>             Load t register item of type <t> onto the stack\v@L8042\v
                                    --
.context @L8080
:z7
:nP-Code Instructions Index [14]
:l13
                                             \aUp\vadvisor.hlp!vx\v \aContents\vadvisor.hlp!hv\v \aIndex\vadvisor.hlp!vx\v \aBack\v!B\v
컴P-Code Instructions Index컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 
  旼쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡
  \aA\v@L8074\v\aB\v@L8075\v\aC\v@L8076\v\aD\v@L8077\v\aE\v@L8078\v\aF\v@L8079\v\aG\v@L807a\v\aH\v@L807b\v\aI\v@L807c\v\aJ\v@L807d\v\aK\v@L807e\v\aL\v@L807f\v쿘\aN\v@L8081\v\aO\v@L8082\v\aP\v@L8083\v\aQ\v@L8084\v\aR\v@L8085\v\aS\v@L8086\v\aT\v@L8087\v\aU\v@L8088\v\aV\v@L8089\v\aW\v@L808a\v\aX-Z\v@L808b\v\a*\v@L8073\v
  읕좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔
 
   \aMul<t>             Multiply top two items on stack\v@L8043\v
   \aMulWWL             Multiply top two words and push long result\v@L8044\v
                                    --
.context @L8081
:z7
:nP-Code Instructions Index [15]
:l14
                                             \aUp\vadvisor.hlp!vx\v \aContents\vadvisor.hlp!hv\v \aIndex\vadvisor.hlp!vx\v \aBack\v!B\v
컴P-Code Instructions Index컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 
  旼쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡
  \aA\v@L8074\v\aB\v@L8075\v\aC\v@L8076\v\aD\v@L8077\v\aE\v@L8078\v\aF\v@L8079\v\aG\v@L807a\v\aH\v@L807b\v\aI\v@L807c\v\aJ\v@L807d\v\aK\v@L807e\v\aL\v@L807f\v\aM\v@L8080\v쿙\aO\v@L8082\v\aP\v@L8083\v\aQ\v@L8084\v\aR\v@L8085\v\aS\v@L8086\v\aT\v@L8087\v\aU\v@L8088\v\aV\v@L8089\v\aW\v@L808a\v\aX-Z\v@L808b\v\a*\v@L8073\v
  읕좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔
 
   \aNegW               Negate word (2's complement)\v@L8045\v
   \aNop                No operation.  Must be the opcode value 0x00\v@L8046\v
   \aNot<t>             Bitwise logical 'not', or negate word\v@L8047\v
                                    --
.context @L8082
:z7
:nP-Code Instructions Index [16]
:l13
                                             \aUp\vadvisor.hlp!vx\v \aContents\vadvisor.hlp!hv\v \aIndex\vadvisor.hlp!vx\v \aBack\v!B\v
컴P-Code Instructions Index컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 
  旼쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡
  \aA\v@L8074\v\aB\v@L8075\v\aC\v@L8076\v\aD\v@L8077\v\aE\v@L8078\v\aF\v@L8079\v\aG\v@L807a\v\aH\v@L807b\v\aI\v@L807c\v\aJ\v@L807d\v\aK\v@L807e\v\aL\v@L807f\v\aM\v@L8080\v\aN\v@L8081\v쿚\aP\v@L8083\v\aQ\v@L8084\v\aR\v@L8085\v\aS\v@L8086\v\aT\v@L8087\v\aU\v@L8088\v\aV\v@L8089\v\aW\v@L808a\v\aX-Z\v@L808b\v\a*\v@L8073\v
  읕좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔
 
 
   \aOr<t>              Bitwise logical 'or' top two words on stack\v@L8048\v
                                    --
.context @L8083
:z7
:nP-Code Instructions Index [17]
:l18
                                             \aUp\vadvisor.hlp!vx\v \aContents\vadvisor.hlp!hv\v \aIndex\vadvisor.hlp!vx\v \aBack\v!B\v
컴P-Code Instructions Index컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 
  旼쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡
  \aA\v@L8074\v\aB\v@L8075\v\aC\v@L8076\v\aD\v@L8077\v\aE\v@L8078\v\aF\v@L8079\v\aG\v@L807a\v\aH\v@L807b\v\aI\v@L807c\v\aJ\v@L807d\v\aK\v@L807e\v\aL\v@L807f\v\aM\v@L8080\v\aN\v@L8081\v\aO\v@L8082\v쿛\aQ\v@L8084\v\aR\v@L8085\v\aS\v@L8086\v\aT\v@L8087\v\aU\v@L8088\v\aV\v@L8089\v\aW\v@L808a\v\aX-Z\v@L808b\v\a*\v@L8073\v
  읕좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔
 
   \aPopIP<n>           Branch indirect through near pointer on top of stack.\v@L8049\v
   \aPopR               Move floating point value to floating point stack\v@L804a\v
   \aPopW<n>            Move floating point value to floating point stack\v@L804b\v
   \aPushCS             Push contents of CS code segment register onto stack\v@L804c\v
   \aPushDS             Push contents of the p-code DS register onto stack\v@L804d\v
   \aPush<t>            Move floating point value onto pcode stack\v@L804e\v
   \aPushIP<n>          Push value for instruction pointer\v@L804f\v
                                    --
.context @L8084
:z7
:nP-Code Instructions Index [18]
:l12
                                             \aUp\vadvisor.hlp!vx\v \aContents\vadvisor.hlp!hv\v \aIndex\vadvisor.hlp!vx\v \aBack\v!B\v
컴P-Code Instructions Index컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 
  旼쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡
  \aA\v@L8074\v\aB\v@L8075\v\aC\v@L8076\v\aD\v@L8077\v\aE\v@L8078\v\aF\v@L8079\v\aG\v@L807a\v\aH\v@L807b\v\aI\v@L807c\v\aJ\v@L807d\v\aK\v@L807e\v\aL\v@L807f\v\aM\v@L8080\v\aN\v@L8081\v\aO\v@L8082\v\aP\v@L8083\v쿜\aR\v@L8085\v\aS\v@L8086\v\aT\v@L8087\v\aU\v@L8088\v\aV\v@L8089\v\aW\v@L808a\v\aX-Z\v@L808b\v\a*\v@L8073\v
  읕좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔
 
   \aQuote<n>           Call quoted subroutine.\v@L8050\v
                                    --
.context @L8085
:z7
:nP-Code Instructions Index [19]
:l14
                                             \aUp\vadvisor.hlp!vx\v \aContents\vadvisor.hlp!hv\v \aIndex\vadvisor.hlp!vx\v \aBack\v!B\v
컴P-Code Instructions Index컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 
  旼쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡
  \aA\v@L8074\v\aB\v@L8075\v\aC\v@L8076\v\aD\v@L8077\v\aE\v@L8078\v\aF\v@L8079\v\aG\v@L807a\v\aH\v@L807b\v\aI\v@L807c\v\aJ\v@L807d\v\aK\v@L807e\v\aL\v@L807f\v\aM\v@L8080\v\aN\v@L8081\v\aO\v@L8082\v\aP\v@L8083\v\aQ\v@L8084\v쿝\aS\v@L8086\v\aT\v@L8087\v\aU\v@L8088\v\aV\v@L8089\v\aW\v@L808a\v\aX-Z\v@L808b\v\a*\v@L8073\v
  읕좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔
 
   \aRem<t>             Remainder of integer division of type <t>\v@L8051\v
   \aRep<t>             Replicate top item on the stack\v@L8052\v
   \aRet                Return from function call\v@L8053\v
                                    --
.context @L8086
:z7
:nP-Code Instructions Index [20]
:l35
                                             \aUp\vadvisor.hlp!vx\v \aContents\vadvisor.hlp!hv\v \aIndex\vadvisor.hlp!vx\v \aBack\v!B\v
컴P-Code Instructions Index컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 
  旼쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡
  \aA\v@L8074\v\aB\v@L8075\v\aC\v@L8076\v\aD\v@L8077\v\aE\v@L8078\v\aF\v@L8079\v\aG\v@L807a\v\aH\v@L807b\v\aI\v@L807c\v\aJ\v@L807d\v\aK\v@L807e\v\aL\v@L807f\v\aM\v@L8080\v\aN\v@L8081\v\aO\v@L8082\v\aP\v@L8083\v\aQ\v@L8084\v\aR\v@L8085\v쿞\aT\v@L8087\v\aU\v@L8088\v\aV\v@L8089\v\aW\v@L808a\v\aX-Z\v@L808b\v\a*\v@L8073\v
  읕좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔
 
   \aSar<t>             Shift Arithmetic Right signed integer\v@L8054\v
   \aSetf<t><n>         Set frame item (integer) to value 1\v@L8055\v
   \aShl<t>             Shift Word/Long Logical Left by n bits\v@L8056\v
   \aShl<t>1            Shift Word Logical Left one bit\v@L8057\v
   \aShr<t>             Shift Word Logical Right by n bits\v@L8058\v
   \aSpillTb            Spill floating point stack to temp area\v@L8059\v
   \aStf<t><n>          Store value to frame relative address\v@L805a\v
   \aStfp<t><n>         Store value to frame relative address and preserve\vStfpBb\v
   \aStg<t><n>          Store value to global address\v@L805c\v
   \aStif<t><n>         Store value indirect through far pointer\v@L805d\v
   \aStifo<t>           Store value indirect through far pointer + offset\v@L805e\v
   \aStifQW<b>          Store indirect bit field into word using far pointer\v@L805f\v
   \aStift<t>           Store item indirect using far pointer in t register\v@L8060\v
   \aStin<t><n>         Store item indirect using near pointer.\v@L8061\v
   \aStinQW<b>          Store indirect bit field into word using near pointer\v@L8062\v
   \aStino<t>           Store value indirect through near pointer + offset\v@L8063\v
   \aStinp<t><n>        Store indirect near and preserve item\v@L8064\v
   \aStint<t>           Store item indirect using t register\v@L8065\v
   \aStixWb             Store the word to *(this + offset)\v@L8066\v
   \aStixLb             Store the long to *(this + offset)\v@L8067\v
   \aSttW               Store top of stack in t register\v@L8068\v
   \aSub<t>             Subtract top two items on stack\v@L8069\v
   \aSwapW              Swap the top two words on the on the stack\v@L806a\v
   \aSwapT              Swap the top two floating point values\v@L806b\v
                                    --
.context @L8087
:z7
:nP-Code Instructions Index [21]
:l12
                                             \aUp\vadvisor.hlp!vx\v \aContents\vadvisor.hlp!hv\v \aIndex\vadvisor.hlp!vx\v \aBack\v!B\v
컴P-Code Instructions Index컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 
  旼쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡
  \aA\v@L8074\v\aB\v@L8075\v\aC\v@L8076\v\aD\v@L8077\v\aE\v@L8078\v\aF\v@L8079\v\aG\v@L807a\v\aH\v@L807b\v\aI\v@L807c\v\aJ\v@L807d\v\aK\v@L807e\v\aL\v@L807f\v\aM\v@L8080\v\aN\v@L8081\v\aO\v@L8082\v\aP\v@L8083\v\aQ\v@L8084\v\aR\v@L8085\v\aS\v@L8086\v쿟\aU\v@L8088\v\aV\v@L8089\v\aW\v@L808a\v\aX-Z\v@L808b\v\a*\v@L8073\v
  읕좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔
 
   No entries.
                                    --
.context @L8088
:z7
:nP-Code Instructions Index [22]
:l12
                                             \aUp\vadvisor.hlp!vx\v \aContents\vadvisor.hlp!hv\v \aIndex\vadvisor.hlp!vx\v \aBack\v!B\v
컴P-Code Instructions Index컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 
  旼쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡
  \aA\v@L8074\v\aB\v@L8075\v\aC\v@L8076\v\aD\v@L8077\v\aE\v@L8078\v\aF\v@L8079\v\aG\v@L807a\v\aH\v@L807b\v\aI\v@L807c\v\aJ\v@L807d\v\aK\v@L807e\v\aL\v@L807f\v\aM\v@L8080\v\aN\v@L8081\v\aO\v@L8082\v\aP\v@L8083\v\aQ\v@L8084\v\aR\v@L8085\v\aS\v@L8086\v\aT\v@L8087\v쿢\aV\v@L8089\v\aW\v@L808a\v\aX-Z\v@L808b\v\a*\v@L8073\v
  읕좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔
 
   \aUnSpillTb          UnSpill floating point stack.\v@L806c\v
                                    --
.context @L8089
:z7
:nP-Code Instructions Index [23]
:l12
                                             \aUp\vadvisor.hlp!vx\v \aContents\vadvisor.hlp!hv\v \aIndex\vadvisor.hlp!vx\v \aBack\v!B\v
컴P-Code Instructions Index컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 
  旼쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡
  \aA\v@L8074\v\aB\v@L8075\v\aC\v@L8076\v\aD\v@L8077\v\aE\v@L8078\v\aF\v@L8079\v\aG\v@L807a\v\aH\v@L807b\v\aI\v@L807c\v\aJ\v@L807d\v\aK\v@L807e\v\aL\v@L807f\v\aM\v@L8080\v\aN\v@L8081\v\aO\v@L8082\v\aP\v@L8083\v\aQ\v@L8084\v\aR\v@L8085\v\aS\v@L8086\v\aT\v@L8087\v\aU\v@L8088\v쿣\aW\v@L808a\v\aX-Z\v@L808b\v\a*\v@L8073\v
  읕좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔
 
   No entries.
                                    --
.context @L808a
:z7
:nP-Code Instructions Index [24]
:l12
                                             \aUp\vadvisor.hlp!vx\v \aContents\vadvisor.hlp!hv\v \aIndex\vadvisor.hlp!vx\v \aBack\v!B\v
컴P-Code Instructions Index컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 
  旼쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡
  \aA\v@L8074\v\aB\v@L8075\v\aC\v@L8076\v\aD\v@L8077\v\aE\v@L8078\v\aF\v@L8079\v\aG\v@L807a\v\aH\v@L807b\v\aI\v@L807c\v\aJ\v@L807d\v\aK\v@L807e\v\aL\v@L807f\v\aM\v@L8080\v\aN\v@L8081\v\aO\v@L8082\v\aP\v@L8083\v\aQ\v@L8084\v\aR\v@L8085\v\aS\v@L8086\v\aT\v@L8087\v\aU\v@L8088\v\aV\v@L8089\v쿥\aX-Z\v@L808b\v\a*\v@L8073\v
  읕좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔
 
  No entries.
                                    --
.context @L808b
:z7
:nP-Code Instructions Index [25]
:l12
                                             \aUp\vadvisor.hlp!vx\v \aContents\vadvisor.hlp!hv\v \aIndex\vadvisor.hlp!vx\v \aBack\v!B\v
컴P-Code Instructions Index컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 
  旼쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡쩡
  \aA\v@L8074\v\aB\v@L8075\v\aC\v@L8076\v\aD\v@L8077\v\aE\v@L8078\v\aF\v@L8079\v\aG\v@L807a\v\aH\v@L807b\v\aI\v@L807c\v\aJ\v@L807d\v\aK\v@L807e\v\aL\v@L807f\v\aM\v@L8080\v\aN\v@L8081\v\aO\v@L8082\v\aP\v@L8083\v\aQ\v@L8084\v\aR\v@L8085\v\aS\v@L8086\v\aT\v@L8087\v\aU\v@L8088\v\aV\v@L8089\v\aW\v@L808a\v쿦-Z\a*\v@L8073\v
  읕좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔좔
 
   \aXor<t>             Bitwise logical 'xor' top two words on stack\v@L806d\v
                                    --
.context errMPCERR
.context @L808c
:z3
:nMPC Errors
 
 \aViewing Errors\vadvisor.hlp!errorview\v                            \aUp\vadvisor.hlp!errortoc\v \aContents\vadvisor.hlp!hv\v \aIndex\vadvisor.hlp!vx\v \aBack\v!B\v
컴컴횺PC Utility컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 
     MPC Errors
 
     Help is available on each of the error numbers listed below.
 
     MPC Fatal Errors
 
     MP1001    MP1041    MP1045    MP1048    MP1080    MP1083
     MP1002    MP1042    MP1046    MP1049    MP1081    MP1084
     MP1010    MP1043    MP1047    MP1051    MP1082    MP1085
     MP1040    MP1044
 
     MPC Nonfatal Errors
 
     MP2081    MP2083    MP2085    MP2087
     MP2082    MP2084    MP2086    MP2088
 
     MPC Warnings
 
     MP4001    MP4003    MP4005    MP4007    MP4009
     MP4002    MP4004    MP4006    MP4008
 
.context MP1001
.context @L808d
:fC70/HELP/PCODE/MPCERR.REF
:z3
                                              \aUp\v@L808c\v \aContents\v@L808c\v \aIndex\vh.index\v \aBack\v!B\v
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 
     MPC fatal error MP1001
 
     cannot open file : 'filename'
 
     The given file either did not exist, could not be opened, or was
     not found.
 
     One or more of the following can cause this error:
 
         The file was read-only or was being used by another process.
 
         An invalid filename or path was specified.
 
         MPC ran out of file handles. To increase the number of
          available file handles, change the FILES setting in CONFIG.SYS.
          FILES=50 is the recommended setting.
 
         The environment settings were invalid.
 
         There was a disk media error or an open floppy disk drive
          door.
 
.context MP1002
.context @L808e
:fC70/HELP/PCODE/MPCERR.REF
:z3
                                              \aUp\v@L808c\v \aContents\v@L808c\v \aIndex\vh.index\v \aBack\v!B\v
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 
     MPC fatal error MP1002
 
     file I/O error : 'filename'
 
     There was an error when working with the given file.
 
     One or more of the following can cause this error:
 
         There was a disk media error or an open floppy disk drive
          door.
 
         The file was read-only or was being used by another process.
 
         There was insufficient space on the specified drive.
 
         The file was corrupt.
 
.context MP1010
.context @L808f
:fC70/HELP/PCODE/MPCERR.REF
:z3
                                              \aUp\v@L808c\v \aContents\v@L808c\v \aIndex\vh.index\v \aBack\v!B\v
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 
     MPC fatal error MP1010
 
     'filename' is not a segmented executable file
 
     The given file was not a valid segmented executable file. MPC can
     only operate on segmented executable files.
 
     Make sure that the given filename was compiled and linked with the
     correct command-line options to generate a segmented executable
     file.
 
     P-code object modules contain special-purpose records that force the
     generation of a segmented executable file. When building an MS-DOS
     p-code program, MPC converts the segmented executable file to an
     unsegmented executable file.
 
.context MP1040
.context @L8090
:fC70/HELP/PCODE/MPCERR.REF
:z3
                                              \aUp\v@L808c\v \aContents\v@L808c\v \aIndex\vh.index\v \aBack\v!B\v
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 
     MPC fatal error MP1040
 
     out of memory
 
     The MPC program ran out of memory and was unable to recover.
 
     One of the following may be a solution:
 
         Remove other programs or drivers running in the system,
          which could be consuming significant amounts of memory.
 
         Recompile some of the p-code functions as native code
          and relink.
 
         Run MPC directly from the command line, instead of from
          CL, LINK, NMAKE, or PWB.
 
.context MP1041
.context @L8091
:fC70/HELP/PCODE/MPCERR.REF
:z3
                                              \aUp\v@L808c\v \aContents\v@L808c\v \aIndex\vh.index\v \aBack\v!B\v
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 
     MPC fatal error MP1041
 
     unsupported fixup; source type 'type' flags 'flags'
 
     MPC has encountered an unsupported relocation fixup in the
     executable file.
 
     This warning can be generated by dynamic-link library (DLL) fixups
     in an MS-DOS executable file. This warning can also be caused by
     using 32-bit code in a p-code executable file. P-code supports only
     16-bit programs.
 
.context MP1042
.context @L8092
:fC70/HELP/PCODE/MPCERR.REF
:z3
                                              \aUp\v@L808c\v \aContents\v@L808c\v \aIndex\vh.index\v \aBack\v!B\v
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 
     MPC fatal error MP1042
 
     too many p-code segments
 
     The p-code limit of 255 segments was exceeded.
 
     Each physical segment containing p-code functions or functions
     referenced by p-code routines is divided into one or more p-code
     logical segments. There is a limit of 255 p-code logical segments
     per executable file.
 
     To reduce the number of physical p-code segments, select segments
     that reference or are referenced by many functions and compile
     them into native code by using #pragma optimize( "q", off ). The
     number of p-code segments can also be reduced by combining physical
     segments.
 
.context MP1043
.context @L8093
:fC70/HELP/PCODE/MPCERR.REF
:z3
                                              \aUp\v@L808c\v \aContents\v@L808c\v \aIndex\vh.index\v \aBack\v!B\v
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 
     MPC fatal error MP1043
 
     too many DLL functions referenced
 
     The maximum number of dynamic-link library (DLL) functions
     referenced from p-code was exceeded. A maximum of 255 DLL entry
     points can be referenced from p-code in each executable file.
 
     To eliminate this error, reduce the DLL reference count by recompiling
     some p-code functions that call DLL functions into native code.
 
.context MP1044
.context @L8094
:fC70/HELP/PCODE/MPCERR.REF
:z3
                                              \aUp\v@L808c\v \aContents\v@L808c\v \aIndex\vh.index\v \aBack\v!B\v
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 
     MPC fatal error MP1044
 
     too many functions referenced by p-code function at 'address'
 
     The maximum number of unique functions referenced by a p-code
     function was exceeded. A maximum of 255 unique functions can
     be referenced by a p-code function.
 
     To find the function that caused this error, look up the given
     map address in the .MAP file generated from the executable file.
     To generate a .MAP file, use the CL /Fm command-line option or
     the LINK /MAP command-line option.
 
     To correct this error, either recompile the routine at the
     specified map address to native code or split the function into
     subfunctions that call fewer functions.
 
.context MP1045
.context @L8095
:fC70/HELP/PCODE/MPCERR.REF
:z3
                                              \aUp\v@L808c\v \aContents\v@L808c\v \aIndex\vh.index\v \aBack\v!B\v
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 
     MPC fatal error MP1045
 
     too many globals referenced by p-code function at 'address'
 
     The maximum number of unique global variables referenced by a
     p-code function was exceeded. A maximum of 255 unique global
     variables can be referenced by a p-code function.
 
     To find the function that caused this error, look up the given
     map address in the .MAP file generated from the executable file.
     To generate a .MAP file, use the CL /Fm command-line option or the
     LINK /MAP command-line option.
 
     To correct this error, either recompile the routine at the
     specified map address to native code or split the function into
     subfunctions that reference fewer global variables.
 
.context MP1046
.context @L8096
:fC70/HELP/PCODE/MPCERR.REF
:z3
                                              \aUp\v@L808c\v \aContents\v@L808c\v \aIndex\vh.index\v \aBack\v!B\v
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 
     MPC fatal error MP1046
 
     unused entry 'number'
 
     MPC has detected an unused entry in the module entry table. Unused
     entries are not currently supported by MPC.
 
.context MP1047
.context @L8097
:fC70/HELP/PCODE/MPCERR.REF
:z3
                                              \aUp\v@L808c\v \aContents\v@L808c\v \aIndex\vh.index\v \aBack\v!B\v
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 
     MPC fatal error MP1047
 
     entry table overflow; attempted to extend segment table to
     'number'
 
     The 64K limit of the segment table was exceeded.
 
     MPC adds an entry to the segment table for each movable p-code
     segment and dynamic-link library (DLL) entry point.
 
     To correct this situation, either reduce the number of p-code
     segments or mark some of the p-code segments as FIXED.
 
.context MP1048
.context @L8098
:fC70/HELP/PCODE/MPCERR.REF
:z3
                                              \aUp\v@L808c\v \aContents\v@L808c\v \aIndex\vh.index\v \aBack\v!B\v
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 
     MPC fatal error MP1048
 
     too many imported functions : 'number'
 
     Too many imported functions were referenced by p-code functions.
     The limit is 4680 imported functions.
 
     Reduce the number of imported functions referenced by p-code
     functions by recompiling p-code functions into native code or by
     moving references to imported function to native code.
 
.context MP1049
.context @L8099
:fC70/HELP/PCODE/MPCERR.REF
:z3
                                              \aUp\v@L808c\v \aContents\v@L808c\v \aIndex\vh.index\v \aBack\v!B\v
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 
     MPC fatal error MP1049
 
     invalid executable file : 'filename'
 
     The given executable file contains errors. MPC will not process
     invalid executable files.
 
     Relink the program so that no errors are generated.
 
.context MP1051
.context @L809a
:fC70/HELP/PCODE/MPCERR.REF
:z3
                                              \aUp\v@L808c\v \aContents\v@L808c\v \aIndex\vh.index\v \aBack\v!B\v
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 
     MPC fatal error MP1051
 
     imported names table overflow
 
     There were too many imported names in the executable file, causing
     the MPC buffer to overflow. The buffer is 64K bytes.
 
     Reduce the number of imported names in the executable file.
 
.context MP1080
.context @L809b
:fC70/HELP/PCODE/MPCERR.REF
:z3
                                              \aUp\v@L808c\v \aContents\v@L808c\v \aIndex\vh.index\v \aBack\v!B\v
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 
     MPC fatal error MP1080
 
     p-code interpreter not found : 'filename'
 
     MPC could not find the p-code interpreter in the given file.
 
     Relink the executable file, making sure that no link errors occur.
     This error can also be caused by adding information to the
     reserved p-code interpreter segment.
 
.context MP1081
.context @L809c
:fC70/HELP/PCODE/MPCERR.REF
:z3
                                              \aUp\v@L808c\v \aContents\v@L808c\v \aIndex\vh.index\v \aBack\v!B\v
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 
     MPC fatal error MP1081
 
     MPC fixup segment not found: 'filename'
 
     MPC could not find any p-code fixup segments in the given
     executable file.
 
     The compiler emits special p-code fixup data to reserved data
     segments. These segments could not be found.
 
.context MP1082
.context @L809d
:fC70/HELP/PCODE/MPCERR.REF
:z3
                                              \aUp\v@L808c\v \aContents\v@L808c\v \aIndex\vh.index\v \aBack\v!B\v
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 
     MPC fatal error MP1082
 
     invalid data found in executable file at 'segment:offset'
 
     MPC detected corrupted code or data in the executable file at
     the given address.
 
     Recompile the source files containing p-code and relink the
     executable file. If the error persists, compile the function
     at the given address into native code.
 
.context MP1083
.context @L809e
:fC70/HELP/PCODE/MPCERR.REF
:z3
                                              \aUp\v@L808c\v \aContents\v@L808c\v \aIndex\vh.index\v \aBack\v!B\v
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 
     MPC fatal error MP1083
 
     segment overflow writing p-code tables in segment 'segment'
 
     The writing of p-code tables at the end of the given segment
     caused the segment to exceed 64K. This segment contains or is
     referenced by p-code functions.
 
     Reduce the size of the given segment and relink. If you are
     generating a Windows executable or are using the LINK /PACKC
     option, you must reserve enough space for the p-code tables
     with the LINK /PACKC:<number> option. The <number> specifies
     the maximum size of a code segment (512 bytes is recommended).
 
.context MP1084
.context @L809f
:fC70/HELP/PCODE/MPCERR.REF
:z3
                                              \aUp\v@L808c\v \aContents\v@L808c\v \aIndex\vh.index\v \aBack\v!B\v
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 
     MPC fatal error MP1084
 
     combined library does not match operating system
 
     MPC attempted to generate a nonsegmented executable file, but
     encountered references to imported functions, indicating a
     protected-mode executable file.
 
     This error is usually caused by using old versions of combined
     libraries when trying to generate a Windows executable with
     p-code. Make sure that the latest versions of combined libraries
     are being linked in.
 
     Relink the executable file using the correct libraries.
 
.context MP1085
.context @L80a0
:fC70/HELP/PCODE/MPCERR.REF
:z3
                                              \aUp\v@L808c\v \aContents\v@L808c\v \aIndex\vh.index\v \aBack\v!B\v
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 
     MPC fatal error MP1085
 
     Windows application does not reference module KERNEL
 
     When generating a real-mode Windows executable file, MPC requires
     a reference to the Windows KERNEL module in the executable file.
     This allows MPC to add the appropriate memory-management information
     to the p-code executable file.
 
     This error is usually caused by a corrupted library.
 
     Relink the executable file, making sure that no errors occur in the
     linking process.
 
.context MP2081
.context @L80a1
:fC70/HELP/PCODE/MPCERR.REF
:z3
                                              \aUp\v@L808c\v \aContents\v@L808c\v \aIndex\vh.index\v \aBack\v!B\v
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 
     MPC error MP2081
 
     missing native entry code for function at 'segment:offset'
 
     MPC detected a p-code function that was called from native code
     but does not have a valid native entry-code sequence.
 
     To find the function that caused this error, look up the given
     map address in the .MAP file generated from the executable file.
     To generate a .MAP file, use the CL /Fm command-line option or the
     LINK /MAP command-line option.
 
     This error can be caused by using #pragma native_caller( off )
     or the CL /Gn command-line option when defining functions that
     are exported.
 
     Recompile and relink the module that contains the function at
     the specified map address, making sure that native entry code
     is generated, then relink the executable file.
 
.context MP2082
.context @L80a2
:fC70/HELP/PCODE/MPCERR.REF
:z3
                                              \aUp\v@L808c\v \aContents\v@L808c\v \aIndex\vh.index\v \aBack\v!B\v
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 
     MPC error MP2082
 
     missing native entry code for exported function at 'segment:offset'
 
     MPC detected an exported p-code function that does not have a
     valid native entry code sequence. All exported p-code functions
     must have native entry code sequences.
 
     To find the function that caused this error, look up the given
     map address in the .MAP file generated from the executable file.
     To generate a .MAP file, use the CL /Fm command-line option or the
     LINK /MAP command-line option.
 
     This error can be caused by using #pragma native_caller( off )
     or the CL /Gn command-line option when defining functions that
     are exported.
 
     Recompile and relink the module that contains the function at
     the specified map address, making sure that native entry code
     is generated, then relink the executable file.
 
.context MP2083
.context @L80a3
:fC70/HELP/PCODE/MPCERR.REF
:z3
                                              \aUp\v@L808c\v \aContents\v@L808c\v \aIndex\vh.index\v \aBack\v!B\v
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 
     MPC error MP2083
 
     calling convention inconsistency: source 'segment:offset',
     target 'segment:offset'
 
     The calling convention of the function reference at the given
     source map address was inconsistent with the calling convention in
     the function defined at the target map address.
 
     To find the functions that caused this error, look up the given
     map addresses in the .MAP file generated from the executable file.
     To generate a .MAP file, use the CL /Fm command-line option or the
     LINK /MAP command-line option.
 
     Check the consistency of the function prototypes used in the given
     functions. Recompile the appropriate modules and relink.
 
.context MP2084
.context @L80a4
:fC70/HELP/PCODE/MPCERR.REF
:z3
                                              \aUp\v@L808c\v \aContents\v@L808c\v \aIndex\vh.index\v \aBack\v!B\v
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 
     MPC error MP2084
 
     parameter length inconsistency: source 'segment:offset',
     target 'segment:offset'
 
     The length of the actual parameters of the function reference at
     the given source map address was inconsistent with the length of the
     formal parameters of the function defined at the target map address.
 
     To find the functions that caused this error, look up the given
     map addresses in the .MAP file generated from the executable file.
     To generate a .MAP file, use the CL /Fm command-line option or the
     LINK /MAP command-line option.
 
     Check the consistency of the function prototypes used in the given
     functions. Recompile the appropriate modules and relink.
 
.context MP2085
.context @L80a5
:fC70/HELP/PCODE/MPCERR.REF
:z3
                                              \aUp\v@L808c\v \aContents\v@L808c\v \aIndex\vh.index\v \aBack\v!B\v
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 
     MPC error MP2085
 
     inconsistent reference made to the function at 'segment:offset'
 
     One or more inconsistent references were made to the function
     at the specified map address. Either the calling convention or
     parameter length was inconsistent.
 
     To find the function that caused this error, look up the given
     map address in the .MAP file generated from the executable file.
     To generate a .MAP file, use the CL /Fm command-line option or the
     LINK /MAP command-line option.
 
     Check the consistency of the function prototypes for the function
     at the given map address and all references to that function.
     Recompile the appropriate modules and relink.
 
.context MP2086
.context @L80a6
:fC70/HELP/PCODE/MPCERR.REF
:z3
                                              \aUp\v@L808c\v \aContents\v@L808c\v \aIndex\vh.index\v \aBack\v!B\v
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 
     MPC error MP2086
 
     p-code version mismatch: compiler 'version1', MPC 'version2'
 
     The versions of the compiler and MPC that were used are
     incompatible. Make sure that compatible versions of the compiler
     and MPC are used when generating p-code programs.
 
     This error can occur when there are multiple versions of the
     compiler or MPC in the path. Check the path to make sure that
     the correct versions are being used.
 
     Either recompile the modules using the appropriate compiler or
     rerun the appropriate version of MPC.
 
.context MP2087
.context @L80a7
:fC70/HELP/PCODE/MPCERR.REF
:z3
                                              \aUp\v@L808c\v \aContents\v@L808c\v \aIndex\vh.index\v \aBack\v!B\v
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 
     MPC error MP2087
 
     p-code version mismatch: p-code interpreter 'version1', MPC
     'version2'
 
     The versions of PCD.LIB and MPC that were used are incompatible.
     Make sure that compatible versions of the p-code interpreter
     library and MPC are used when generating p-code programs.
 
     This error can occur when there are multiple versions of the
     p-code interpreter or MPC in the path. Check the path to make
     sure that the correct versions are being used.
 
     Either relink using the appropriate version of PCD.LIB or rerun the
     appropriate version of MPC.
 
.context MP2088
.context @L80a8
:fC70/HELP/PCODE/MPCERR.REF
:z3
                                              \aUp\v@L808c\v \aContents\v@L808c\v \aIndex\vh.index\v \aBack\v!B\v
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 
     MPC error MP2088
 
     intersegment call with near source or target: source
     'segment:offset', target 'segment:offset'
 
     The source or target of a function call was declared to be near,
     but the source and target were in different physical segments. The
     caller (source) was in a p-code function, and the callee (target)
     was a native function.
 
     Make the calling conventions of the source function call and the
     target function prototype match, or make sure that both functions
     are placed in the same physical segment.
 
     To find the functions that caused this warning, look up the given
     map addresses in the .MAP file generated from the executable file.
     To generate a .MAP file, use the CL /Fm command-line option or the
     LINK /MAP command-line option.
 
.context MP4001
.context @L80a9
:fC70/HELP/PCODE/MPCERR.REF
:z3
                                              \aUp\v@L808c\v \aContents\v@L808c\v \aIndex\vh.index\v \aBack\v!B\v
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 
     MPC warning MP4001
 
     interpreter segment not FIXED
 
     The segment containing the p-code interpreter must be fixed
     when generating real-mode Windows executable files.
 
     MPC considered the p-code interpreter segment to be FIXED.
 
     The following lines in a LINK module-definition (.DEF) file will
     eliminate this warning:
 
          SEGMENTS
              $$PCD_INTERP   FIXED
 
.context MP4002
.context @L80aa
:fC70/HELP/PCODE/MPCERR.REF
:z3
                                              \aUp\v@L808c\v \aContents\v@L808c\v \aIndex\vh.index\v \aBack\v!B\v
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 
     MPC warning MP4002
 
     executable file contains no p-code : 'filename'
 
     The given .EXE or .DLL file did not contain any p-code.
 
     MPC copied the given file to the output filename without
     modification.
 
.context MP4003
.context @L80ab
:fC70/HELP/PCODE/MPCERR.REF
:z3
                                              \aUp\v@L808c\v \aContents\v@L808c\v \aIndex\vh.index\v \aBack\v!B\v
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 
     MPC warning MP4003
 
     file already processed by MPC : 'filename'
 
     The given .EXE or .DLL file has already been processed by MPC.
 
     MPC copied the given file to the output filename without
     modification.
 
.context MP4004
.context @L80ac
:fC70/HELP/PCODE/MPCERR.REF
:z3
                                              \aUp\v@L808c\v \aContents\v@L808c\v \aIndex\vh.index\v \aBack\v!B\v
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 
     MPC warning MP4004
 
     far data reference to movable segment: source 'segment:????',
     target 'segment:offset'
 
     The source segment contained a far data reference to the target
     map address, which is in a movable segment. This is illegal when
     creating a real-mode Windows executable file.
 
     These references are dangerous when running Windows in real mode
     because data segments can move, causing the references to be
     invalid.
 
     To find the function that caused this warning, look up the given
     map address in the .MAP file generated from the executable file.
     To generate a .MAP file, use the CL /Fm command-line option or the
     LINK /MAP command-line option.
 
     Relink the executable file using a module-definition (.DEF) file to
     mark the target segment as FIXED or to mark the executable file as
     PROTMODE.
 
.context MP4005
.context @L80ad
:fC70/HELP/PCODE/MPCERR.REF
:z3
                                              \aUp\v@L808c\v \aContents\v@L808c\v \aIndex\vh.index\v \aBack\v!B\v
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 
     MPC warning MP4005
 
     interpreter debug data segment not FIXED
 
     The segment containing the p-code interpreter debug data must be
     FIXED when when creating a real-mode Windows executable file.
 
     MPC considered the interpreter debug data segment to be FIXED.
 
.context MP4006
.context @L80ae
:fC70/HELP/PCODE/MPCERR.REF
:z3
                                              \aUp\v@L808c\v \aContents\v@L808c\v \aIndex\vh.index\v \aBack\v!B\v
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 
     MPC warning MP4006
 
     CVPACK has not been run on this executable file
 
     The executable file contains Microsoft symbolic debugging
     information, but CVPACK has not been run.
 
     MPC requires CVPACK-processed debugging information.
 
     Run CVPACK on the executable file, then rerun MPC.
 
.context MP4007
.context @L80af
:fC70/HELP/PCODE/MPCERR.REF
:z3
                                              \aUp\v@L808c\v \aContents\v@L808c\v \aIndex\vh.index\v \aBack\v!B\v
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 
     MPC warning MP4007
 
     MAP file parse failed at line 'number' in file 'filename'
 
     MPC could not read the map (.MAP) file for this executable file.
 
     The map file was ignored.
 
     Either relink the executable file to generate a new map file or
     delete the current corrupt map file.
 
.context MP4008
.context @L80b0
:fC70/HELP/PCODE/MPCERR.REF
:z3
                                              \aUp\v@L808c\v \aContents\v@L808c\v \aIndex\vh.index\v \aBack\v!B\v
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 
     MPC warning MP4008
 
     internal optimization error; turn off quoting for 'segment:offset'
 
     A physical segment used more than 256 global variables and
     functions or contained more than 256 functions. This can cause
     problems when using p-code quoting optimization.
 
     To find the function that caused this warning, look up the given
     map address in the .MAP file generated from the executable file.
     To generate a .MAP file, use the CL /Fm command-line option or the
     LINK /MAP command-line option.
 
     To turn off the p-code quoting optimization, use #pragma
     optimize( "f", off ) or the /Of- command-line option.
 
.context MP4009
.context @L80b1
:fC70/HELP/PCODE/MPCERR.REF
:z3
                                              \aUp\v@L808c\v \aContents\v@L808c\v \aIndex\vh.index\v \aBack\v!B\v
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 
     MPC warning MP4009
 
     resources found in executable; should run MPC before adding
     resources
 
     There were resources found in the source executable given to
     MPC. This can cause MPC to generate an invalid executable file.
 
     Run MPC before adding resources with RC or another resource
     compiler or editor.
.context h.title
.context @L80b2
P-Code Instructions
